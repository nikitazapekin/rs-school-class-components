"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/reselect";
exports.ids = ["vendor-chunks/reselect"];
exports.modules = {

/***/ "(ssr)/./node_modules/reselect/dist/reselect.mjs":
/*!*************************************************!*\
  !*** ./node_modules/reselect/dist/reselect.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: () => (/* binding */ createSelector),\n/* harmony export */   createSelectorCreator: () => (/* binding */ createSelectorCreator),\n/* harmony export */   createStructuredSelector: () => (/* binding */ createStructuredSelector),\n/* harmony export */   lruMemoize: () => (/* binding */ lruMemoize),\n/* harmony export */   referenceEqualityCheck: () => (/* binding */ referenceEqualityCheck),\n/* harmony export */   setGlobalDevModeChecks: () => (/* binding */ setGlobalDevModeChecks),\n/* harmony export */   unstable_autotrackMemoize: () => (/* binding */ autotrackMemoize),\n/* harmony export */   weakMapMemoize: () => (/* binding */ weakMapMemoize)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = function runIdentityFunctionCheck(resultFunc, inputSelectorsResults, outputSelectorResult) {\n  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\n    var isInputSameAsOutput = false;\n    try {\n      var emptyObject = {};\n      if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;\n    } catch (_unused) {}\n    if (isInputSameAsOutput) {\n      var stack = void 0;\n      try {\n        throw new Error();\n      } catch (e) {\n        ;\n        stack = e.stack;\n      }\n      console.warn(\"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\", {\n        stack: stack\n      });\n    }\n  }\n};\n\n// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck = function runInputStabilityCheck(inputSelectorResultsObject, options, inputSelectorArgs) {\n  var memoize = options.memoize,\n    memoizeOptions = options.memoizeOptions;\n  var inputSelectorResults = inputSelectorResultsObject.inputSelectorResults,\n    inputSelectorResultsCopy = inputSelectorResultsObject.inputSelectorResultsCopy;\n  var createAnEmptyObject = memoize.apply(void 0, [function () {\n    return {};\n  }].concat(_toConsumableArray(memoizeOptions)));\n  var areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n  if (!areInputSelectorResultsEqual) {\n    var stack = void 0;\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      stack = e.stack;\n    }\n    console.warn(\"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\", {\n      arguments: inputSelectorArgs,\n      firstInputs: inputSelectorResults,\n      secondInputs: inputSelectorResultsCopy,\n      stack: stack\n    });\n  }\n};\n\n// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks = {\n  inputStabilityCheck: \"once\",\n  identityFunctionCheck: \"once\"\n};\nvar setGlobalDevModeChecks = function setGlobalDevModeChecks(devModeChecks) {\n  Object.assign(globalDevModeChecks, devModeChecks);\n};\n\n// src/utils.ts\nvar NOT_FOUND = /* @__PURE__ */Symbol(\"NOT_FOUND\");\nfunction assertIsFunction(func) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected a function, instead received \".concat(_typeof(func));\n  if (typeof func !== \"function\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsObject(object) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected an object, instead received \".concat(_typeof(object));\n  if (_typeof(object) !== \"object\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsArrayOfFunctions(array) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected all items to be functions, instead received the following types: \";\n  if (!array.every(function (item) {\n    return typeof item === \"function\";\n  })) {\n    var itemTypes = array.map(function (item) {\n      return typeof item === \"function\" ? \"function \".concat(item.name || \"unnamed\", \"()\") : _typeof(item);\n    }).join(\", \");\n    throw new TypeError(\"\".concat(errorMessage, \"[\").concat(itemTypes, \"]\"));\n  }\n}\nvar ensureIsArray = function ensureIsArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\nfunction getDependencies(createSelectorArgs) {\n  var dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n  assertIsArrayOfFunctions(dependencies, \"createSelector expects all input-selectors to be functions, but received the following types: \");\n  return dependencies;\n}\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n  var inputSelectorResults = [];\n  var length = dependencies.length;\n  for (var i = 0; i < length; i++) {\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n  }\n  return inputSelectorResults;\n}\nvar getDevModeChecksExecutionInfo = function getDevModeChecksExecutionInfo(firstRun, devModeChecks) {\n  var _globalDevModeChecks$ = _objectSpread(_objectSpread({}, globalDevModeChecks), devModeChecks),\n    identityFunctionCheck = _globalDevModeChecks$.identityFunctionCheck,\n    inputStabilityCheck = _globalDevModeChecks$.inputStabilityCheck;\n  return {\n    identityFunctionCheck: {\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n      run: runInputStabilityCheck\n    }\n  };\n};\n\n// src/autotrackMemoize/autotracking.ts\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\nvar Cell = /*#__PURE__*/function () {\n  function Cell(initialValue) {\n    var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n    _classCallCheck(this, Cell);\n    this.revision = $REVISION;\n    this._value = void 0;\n    this._lastValue = void 0;\n    this._isEqual = tripleEq;\n    this._value = this._lastValue = initialValue;\n    this._isEqual = isEqual;\n  }\n  // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n  return _createClass(Cell, [{\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER;\n      (_CURRENT_TRACKER = CURRENT_TRACKER) === null || _CURRENT_TRACKER === void 0 || _CURRENT_TRACKER.add(this);\n      return this._value;\n    }\n    // Whenever a storage value is updated, we bump the global revision clock,\n    // assign the revision for this storage to the new value, _and_ we schedule a\n    // rerender. This is important, and it's what makes autotracking  _pull_\n    // based. We don't actively tell the caches which depend on the storage that\n    // anything has happened. Instead, we recompute the caches when needed.\n    ,\n    set: function set(newValue) {\n      if (this.value === newValue) return;\n      this._value = newValue;\n      this.revision = ++$REVISION;\n    }\n  }]);\n}();\nfunction tripleEq(a, b) {\n  return a === b;\n}\nvar TrackingCache = /*#__PURE__*/function () {\n  function TrackingCache(fn) {\n    _classCallCheck(this, TrackingCache);\n    this._cachedValue = void 0;\n    this._cachedRevision = -1;\n    this._deps = [];\n    this.hits = 0;\n    this.fn = void 0;\n    this.fn = fn;\n  }\n  return _createClass(TrackingCache, [{\n    key: \"clear\",\n    value: function clear() {\n      this._cachedValue = void 0;\n      this._cachedRevision = -1;\n      this._deps = [];\n      this.hits = 0;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER2;\n      if (this.revision > this._cachedRevision) {\n        var fn = this.fn;\n        var currentTracker = /* @__PURE__ */new Set();\n        var prevTracker = CURRENT_TRACKER;\n        CURRENT_TRACKER = currentTracker;\n        this._cachedValue = fn();\n        CURRENT_TRACKER = prevTracker;\n        this.hits++;\n        this._deps = Array.from(currentTracker);\n        this._cachedRevision = this.revision;\n      }\n      (_CURRENT_TRACKER2 = CURRENT_TRACKER) === null || _CURRENT_TRACKER2 === void 0 || _CURRENT_TRACKER2.add(this);\n      return this._cachedValue;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return Math.max.apply(Math, _toConsumableArray(this._deps.map(function (d) {\n        return d.revision;\n      })).concat([0]));\n    }\n  }]);\n}();\nfunction getValue(cell) {\n  if (!(cell instanceof Cell)) {\n    console.warn(\"Not a valid cell! \", cell);\n  }\n  return cell.value;\n}\nfunction setValue(storage, value) {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\"setValue must be passed a tracked store created with `createStorage`.\");\n  }\n  storage.value = storage._lastValue = value;\n}\nfunction createCell(initialValue) {\n  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n  return new Cell(initialValue, isEqual);\n}\nfunction createCache(fn) {\n  assertIsFunction(fn, \"the first parameter to `createCache` must be a function\");\n  return new TrackingCache(fn);\n}\n\n// src/autotrackMemoize/tracking.ts\nvar neverEq = function neverEq(a, b) {\n  return false;\n};\nfunction createTag() {\n  return createCell(null, neverEq);\n}\nfunction dirtyTag(tag, value) {\n  setValue(tag, value);\n}\nvar consumeCollection = function consumeCollection(node) {\n  var tag = node.collectionTag;\n  if (tag === null) {\n    tag = node.collectionTag = createTag();\n  }\n  getValue(tag);\n};\nvar dirtyCollection = function dirtyCollection(node) {\n  var tag = node.collectionTag;\n  if (tag !== null) {\n    dirtyTag(tag, null);\n  }\n};\n\n// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\nvar ObjectTreeNode = /*#__PURE__*/_createClass(function ObjectTreeNode(value) {\n  _classCallCheck(this, ObjectTreeNode);\n  this.proxy = new Proxy(this, objectProxyHandler);\n  this.tag = createTag();\n  this.tags = {};\n  this.children = {};\n  this.collectionTag = null;\n  this.id = nextId++;\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\nvar objectProxyHandler = {\n  get: function get(node, key) {\n    function calculateResult() {\n      var value = node.value;\n      var childValue = Reflect.get(value, key);\n      if (_typeof(key) === \"symbol\") {\n        return childValue;\n      }\n      if (key in proto) {\n        return childValue;\n      }\n      if (_typeof(childValue) === \"object\" && childValue !== null) {\n        var childNode = node.children[key];\n        if (childNode === void 0) {\n          childNode = node.children[key] = createNode(childValue);\n        }\n        if (childNode.tag) {\n          getValue(childNode.tag);\n        }\n        return childNode.proxy;\n      } else {\n        var tag = node.tags[key];\n        if (tag === void 0) {\n          tag = node.tags[key] = createTag();\n          tag.value = childValue;\n        }\n        getValue(tag);\n        return childValue;\n      }\n    }\n    var res = calculateResult();\n    return res;\n  },\n  ownKeys: function ownKeys(node) {\n    consumeCollection(node);\n    return Reflect.ownKeys(node.value);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(node, prop) {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\n  },\n  has: function has(node, prop) {\n    return Reflect.has(node.value, prop);\n  }\n};\nvar ArrayTreeNode = /*#__PURE__*/_createClass(function ArrayTreeNode(value) {\n  _classCallCheck(this, ArrayTreeNode);\n  this.proxy = new Proxy([this], arrayProxyHandler);\n  this.tag = createTag();\n  this.tags = {};\n  this.children = {};\n  this.collectionTag = null;\n  this.id = nextId++;\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\nvar arrayProxyHandler = {\n  get: function get(_ref, key) {\n    var _ref2 = _slicedToArray(_ref, 1),\n      node = _ref2[0];\n    if (key === \"length\") {\n      consumeCollection(node);\n    }\n    return objectProxyHandler.get(node, key);\n  },\n  ownKeys: function ownKeys(_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n      node = _ref4[0];\n    return objectProxyHandler.ownKeys(node);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_ref5, prop) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n      node = _ref6[0];\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n  },\n  has: function has(_ref7, prop) {\n    var _ref8 = _slicedToArray(_ref7, 1),\n      node = _ref8[0];\n    return objectProxyHandler.has(node, prop);\n  }\n};\nfunction createNode(value) {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value);\n  }\n  return new ObjectTreeNode(value);\n}\nfunction updateNode(node, newValue) {\n  var value = node.value,\n    tags = node.tags,\n    children = node.children;\n  node.value = newValue;\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n    dirtyCollection(node);\n  } else {\n    if (value !== newValue) {\n      var oldKeysSize = 0;\n      var newKeysSize = 0;\n      var anyKeysAdded = false;\n      for (var _key in value) {\n        oldKeysSize++;\n      }\n      for (var key in newValue) {\n        newKeysSize++;\n        if (!(key in value)) {\n          anyKeysAdded = true;\n          break;\n        }\n      }\n      var isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n      if (isDifferent) {\n        dirtyCollection(node);\n      }\n    }\n  }\n  for (var _key2 in tags) {\n    var childValue = value[_key2];\n    var newChildValue = newValue[_key2];\n    if (childValue !== newChildValue) {\n      dirtyCollection(node);\n      dirtyTag(tags[_key2], newChildValue);\n    }\n    if (_typeof(newChildValue) === \"object\" && newChildValue !== null) {\n      delete tags[_key2];\n    }\n  }\n  for (var _key3 in children) {\n    var childNode = children[_key3];\n    var _newChildValue = newValue[_key3];\n    var _childValue = childNode.value;\n    if (_childValue === _newChildValue) {\n      continue;\n    } else if (_typeof(_newChildValue) === \"object\" && _newChildValue !== null) {\n      updateNode(childNode, _newChildValue);\n    } else {\n      deleteNode(childNode);\n      delete children[_key3];\n    }\n  }\n}\nfunction deleteNode(node) {\n  if (node.tag) {\n    dirtyTag(node.tag, null);\n  }\n  dirtyCollection(node);\n  for (var key in node.tags) {\n    dirtyTag(node.tags[key], null);\n  }\n  for (var _key4 in node.children) {\n    deleteNode(node.children[_key4]);\n  }\n}\n\n// src/lruMemoize.ts\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = void 0;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    });\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex];\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    }\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      entries.unshift({\n        key: key,\n        value: value\n      });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\nvar referenceEqualityCheck = function referenceEqualityCheck(a, b) {\n  return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    }\n    var length = prev.length;\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\nfunction lruMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = _typeof(equalityCheckOrOptions) === \"object\" ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n    equalityCheck = _providedOptions$equa === void 0 ? referenceEqualityCheck : _providedOptions$equa,\n    _providedOptions$maxS = providedOptions.maxSize,\n    maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n    resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var resultsCount = 0;\n  var cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n  function memoized() {\n    var value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      value = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n        if (matchingEntry) {\n          value = matchingEntry.value;\n          resultsCount !== 0 && resultsCount--;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = function () {\n    cache.clear();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func) {\n  var node = createNode([]);\n  var lastArgs = null;\n  var shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n  var cache = createCache(function () {\n    var res = func.apply(null, node.proxy);\n    return res;\n  });\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments);\n      lastArgs = arguments;\n    }\n    return cache.value;\n  }\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n  return memoized;\n}\n\n// src/weakMapMemoize.ts\nvar StrongRef = /*#__PURE__*/function () {\n  function StrongRef(value) {\n    _classCallCheck(this, StrongRef);\n    this.value = value;\n  }\n  return _createClass(StrongRef, [{\n    key: \"deref\",\n    value: function deref() {\n      return this.value;\n    }\n  }]);\n}();\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\nfunction weakMapMemoize(func) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var fnNode = createCacheNode();\n  var resultEqualityCheck = options.resultEqualityCheck;\n  var lastResult;\n  var resultsCount = 0;\n  function memoized() {\n    var cacheNode = fnNode;\n    var length = arguments.length;\n    for (var i = 0, l = length; i < l; i++) {\n      var arg = arguments[i];\n      if (typeof arg === \"function\" || _typeof(arg) === \"object\" && arg !== null) {\n        var objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = /* @__PURE__ */new WeakMap();\n        }\n        var objectNode = objectCache.get(arg);\n        if (objectNode === void 0) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        var primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = /* @__PURE__ */new Map();\n        }\n        var primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === void 0) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    var terminatedNode = cacheNode;\n    var result;\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v;\n    } else {\n      result = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        var _lastResult$deref, _lastResult, _lastResult$deref2;\n        var lastResultValue = (_lastResult$deref = (_lastResult = lastResult) === null || _lastResult === void 0 || (_lastResult$deref2 = _lastResult.deref) === null || _lastResult$deref2 === void 0 ? void 0 : _lastResult$deref2.call(_lastResult)) !== null && _lastResult$deref !== void 0 ? _lastResult$deref : lastResult;\n        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n          result = lastResultValue;\n          resultsCount !== 0 && resultsCount--;\n        }\n        var needsWeakRef = _typeof(result) === \"object\" && result !== null || typeof result === \"function\";\n        lastResult = needsWeakRef ? new Ref(result) : result;\n      }\n    }\n    terminatedNode.s = TERMINATED;\n    terminatedNode.v = result;\n    return result;\n  }\n  memoized.clearCache = function () {\n    fnNode = createCacheNode();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions) {\n  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    memoizeOptionsFromArgs[_key5 - 1] = arguments[_key5];\n  }\n  var createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n    memoize: memoizeOrOptions,\n    memoizeOptions: memoizeOptionsFromArgs\n  } : memoizeOrOptions;\n  var createSelector2 = function createSelector2() {\n    for (var _len2 = arguments.length, createSelectorArgs = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {\n      createSelectorArgs[_key6] = arguments[_key6];\n    }\n    var _recomputations = 0;\n    var _dependencyRecomputations = 0;\n    var _lastResult2;\n    var directlyPassedOptions = {};\n    var resultFunc = createSelectorArgs.pop();\n    if (_typeof(resultFunc) === \"object\") {\n      directlyPassedOptions = resultFunc;\n      resultFunc = createSelectorArgs.pop();\n    }\n    assertIsFunction(resultFunc, \"createSelector expects an output function after the inputs, but received: [\".concat(_typeof(resultFunc), \"]\"));\n    var combinedOptions = _objectSpread(_objectSpread({}, createSelectorCreatorOptions), directlyPassedOptions);\n    var memoize = combinedOptions.memoize,\n      _combinedOptions$memo = combinedOptions.memoizeOptions,\n      memoizeOptions = _combinedOptions$memo === void 0 ? [] : _combinedOptions$memo,\n      _combinedOptions$args = combinedOptions.argsMemoize,\n      argsMemoize = _combinedOptions$args === void 0 ? weakMapMemoize : _combinedOptions$args,\n      _combinedOptions$args2 = combinedOptions.argsMemoizeOptions,\n      argsMemoizeOptions = _combinedOptions$args2 === void 0 ? [] : _combinedOptions$args2,\n      _combinedOptions$devM = combinedOptions.devModeChecks,\n      devModeChecks = _combinedOptions$devM === void 0 ? {} : _combinedOptions$devM;\n    var finalMemoizeOptions = ensureIsArray(memoizeOptions);\n    var finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n    var dependencies = getDependencies(createSelectorArgs);\n    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {\n      _recomputations++;\n      return resultFunc.apply(null, arguments);\n    }].concat(_toConsumableArray(finalMemoizeOptions)));\n    var firstRun = true;\n    var selector = argsMemoize.apply(void 0, [function dependenciesChecker() {\n      _dependencyRecomputations++;\n      var inputSelectorResults = collectInputSelectorResults(dependencies, arguments);\n      _lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);\n      if (true) {\n        var _getDevModeChecksExec = getDevModeChecksExecutionInfo(firstRun, devModeChecks),\n          identityFunctionCheck = _getDevModeChecksExec.identityFunctionCheck,\n          inputStabilityCheck = _getDevModeChecksExec.inputStabilityCheck;\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(resultFunc, inputSelectorResults, _lastResult2);\n        }\n        if (inputStabilityCheck.shouldRun) {\n          var inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);\n          inputStabilityCheck.run({\n            inputSelectorResults: inputSelectorResults,\n            inputSelectorResultsCopy: inputSelectorResultsCopy\n          }, {\n            memoize: memoize,\n            memoizeOptions: finalMemoizeOptions\n          }, arguments);\n        }\n        if (firstRun) firstRun = false;\n      }\n      return _lastResult2;\n    }].concat(_toConsumableArray(finalArgsMemoizeOptions)));\n    return Object.assign(selector, {\n      resultFunc: resultFunc,\n      memoizedResultFunc: memoizedResultFunc,\n      dependencies: dependencies,\n      dependencyRecomputations: function dependencyRecomputations() {\n        return _dependencyRecomputations;\n      },\n      resetDependencyRecomputations: function resetDependencyRecomputations() {\n        _dependencyRecomputations = 0;\n      },\n      lastResult: function lastResult() {\n        return _lastResult2;\n      },\n      recomputations: function recomputations() {\n        return _recomputations;\n      },\n      resetRecomputations: function resetRecomputations() {\n        _recomputations = 0;\n      },\n      memoize: memoize,\n      argsMemoize: argsMemoize\n    });\n  };\n  Object.assign(createSelector2, {\n    withTypes: function withTypes() {\n      return createSelector2;\n    }\n  });\n  return createSelector2;\n}\nvar createSelector = /* @__PURE__ */createSelectorCreator(weakMapMemoize);\n\n// src/createStructuredSelector.ts\nvar createStructuredSelector = Object.assign(function (inputSelectorsObject) {\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\n  assertIsObject(inputSelectorsObject, \"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a \".concat(_typeof(inputSelectorsObject)));\n  var inputSelectorKeys = Object.keys(inputSelectorsObject);\n  var dependencies = inputSelectorKeys.map(function (key) {\n    return inputSelectorsObject[key];\n  });\n  var structuredSelector = selectorCreator(dependencies, function () {\n    for (var _len3 = arguments.length, inputSelectorResults = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {\n      inputSelectorResults[_key7] = arguments[_key7];\n    }\n    return inputSelectorResults.reduce(function (composition, value, index) {\n      composition[inputSelectorKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n  return structuredSelector;\n}, {\n  withTypes: function withTypes() {\n    return createStructuredSelector;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZGlzdC9yZXNlbGVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxJQUFJQSx3QkFBd0IsR0FBRyxTQUEzQkEsd0JBQXdCQSxDQUFJQyxVQUFVLEVBQUVDLHFCQUFxQixFQUFFQyxvQkFBb0IsRUFBSztFQUMxRixJQUFJRCxxQkFBcUIsQ0FBQ0UsTUFBTSxLQUFLLENBQUMsSUFBSUYscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEtBQUtDLG9CQUFvQixFQUFFO0lBQzNGLElBQUlFLG1CQUFtQixHQUFHLEtBQUs7SUFDL0IsSUFBSTtNQUNGLElBQU1DLFdBQVcsR0FBRyxDQUFDLENBQUM7TUFDdEIsSUFBSUwsVUFBVSxDQUFDSyxXQUFXLENBQUMsS0FBS0EsV0FBVyxFQUN6Q0QsbUJBQW1CLEdBQUcsSUFBSTtJQUM5QixDQUFDLENBQUMsT0FBQUUsT0FBQSxFQUFNLENBQ1I7SUFDQSxJQUFJRixtQkFBbUIsRUFBRTtNQUN2QixJQUFJRyxLQUFLLEdBQUcsS0FBSyxDQUFDO01BQ2xCLElBQUk7UUFDRixNQUFNLElBQUlDLEtBQUssQ0FBQyxDQUFDO01BQ25CLENBQUMsQ0FBQyxPQUFPQyxDQUFDLEVBQUU7UUFDVjtRQUNHRixLQUFLLEdBQUtFLENBQUMsQ0FBWEYsS0FBSztNQUNWO01BQ0FHLE9BQU8sQ0FBQ0MsSUFBSSxDQUNWLGlUQUFpVCxFQUNqVDtRQUFFSixLQUFLLEVBQUxBO01BQU0sQ0FDVixDQUFDO0lBQ0g7RUFDRjtBQUNGLENBQUM7O0FBRUQ7QUFDQSxJQUFJSyxzQkFBc0IsR0FBRyxTQUF6QkEsc0JBQXNCQSxDQUFJQywwQkFBMEIsRUFBRUMsT0FBTyxFQUFFQyxpQkFBaUIsRUFBSztFQUN2RixJQUFRQyxPQUFPLEdBQXFCRixPQUFPLENBQW5DRSxPQUFPO0lBQUVDLGNBQWMsR0FBS0gsT0FBTyxDQUExQkcsY0FBYztFQUMvQixJQUFRQyxvQkFBb0IsR0FBK0JMLDBCQUEwQixDQUE3RUssb0JBQW9CO0lBQUVDLHdCQUF3QixHQUFLTiwwQkFBMEIsQ0FBdkRNLHdCQUF3QjtFQUN0RCxJQUFNQyxtQkFBbUIsR0FBR0osT0FBTyxDQUFBSyxLQUFBLFVBQUM7SUFBQSxPQUFPLENBQUMsQ0FBQztFQUFBLENBQUMsRUFBQUMsTUFBQSxDQUFBQyxrQkFBQSxDQUFLTixjQUFjLEdBQUM7RUFDbEUsSUFBTU8sNEJBQTRCLEdBQUdKLG1CQUFtQixDQUFDQyxLQUFLLENBQUMsSUFBSSxFQUFFSCxvQkFBb0IsQ0FBQyxLQUFLRSxtQkFBbUIsQ0FBQ0MsS0FBSyxDQUFDLElBQUksRUFBRUYsd0JBQXdCLENBQUM7RUFDeEosSUFBSSxDQUFDSyw0QkFBNEIsRUFBRTtJQUNqQyxJQUFJakIsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNsQixJQUFJO01BQ0YsTUFBTSxJQUFJQyxLQUFLLENBQUMsQ0FBQztJQUNuQixDQUFDLENBQUMsT0FBT0MsQ0FBQyxFQUFFO01BQ1Y7TUFDR0YsS0FBSyxHQUFLRSxDQUFDLENBQVhGLEtBQUs7SUFDVjtJQUNBRyxPQUFPLENBQUNDLElBQUksQ0FDVix1VEFBdVQsRUFDdlQ7TUFDRWMsU0FBUyxFQUFFVixpQkFBaUI7TUFDNUJXLFdBQVcsRUFBRVIsb0JBQW9CO01BQ2pDUyxZQUFZLEVBQUVSLHdCQUF3QjtNQUN0Q1osS0FBSyxFQUFMQTtJQUNGLENBQ0YsQ0FBQztFQUNIO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBLElBQUlxQixtQkFBbUIsR0FBRztFQUN4QkMsbUJBQW1CLEVBQUUsTUFBTTtFQUMzQkMscUJBQXFCLEVBQUU7QUFDekIsQ0FBQztBQUNELElBQUlDLHNCQUFzQixHQUFHLFNBQXpCQSxzQkFBc0JBLENBQUlDLGFBQWEsRUFBSztFQUM5Q0MsTUFBTSxDQUFDQyxNQUFNLENBQUNOLG1CQUFtQixFQUFFSSxhQUFhLENBQUM7QUFDbkQsQ0FBQzs7QUFFRDtBQUNBLElBQUlHLFNBQVMsR0FBRyxlQUFnQkMsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUNuRCxTQUFTQyxnQkFBZ0JBLENBQUNDLElBQUksRUFBeUU7RUFBQSxJQUF2RUMsWUFBWSxHQUFBZCxTQUFBLENBQUF0QixNQUFBLFFBQUFzQixTQUFBLFFBQUFlLFNBQUEsR0FBQWYsU0FBQSwrQ0FBQUgsTUFBQSxDQUFBbUIsT0FBQSxDQUFtREgsSUFBSTtFQUNqRyxJQUFJLE9BQU9BLElBQUksS0FBSyxVQUFVLEVBQUU7SUFDOUIsTUFBTSxJQUFJSSxTQUFTLENBQUNILFlBQVksQ0FBQztFQUNuQztBQUNGO0FBQ0EsU0FBU0ksY0FBY0EsQ0FBQ0MsTUFBTSxFQUEwRTtFQUFBLElBQXhFTCxZQUFZLEdBQUFkLFNBQUEsQ0FBQXRCLE1BQUEsUUFBQXNCLFNBQUEsUUFBQWUsU0FBQSxHQUFBZixTQUFBLDhDQUFBSCxNQUFBLENBQUFtQixPQUFBLENBQWtERyxNQUFNO0VBQ2xHLElBQUlILE9BQUEsQ0FBT0csTUFBTSxNQUFLLFFBQVEsRUFBRTtJQUM5QixNQUFNLElBQUlGLFNBQVMsQ0FBQ0gsWUFBWSxDQUFDO0VBQ25DO0FBQ0Y7QUFDQSxTQUFTTSx3QkFBd0JBLENBQUNDLEtBQUssRUFBK0Y7RUFBQSxJQUE3RlAsWUFBWSxHQUFBZCxTQUFBLENBQUF0QixNQUFBLFFBQUFzQixTQUFBLFFBQUFlLFNBQUEsR0FBQWYsU0FBQTtFQUNuRCxJQUFJLENBQUNxQixLQUFLLENBQUNDLEtBQUssQ0FBQyxVQUFDQyxJQUFJO0lBQUEsT0FBSyxPQUFPQSxJQUFJLEtBQUssVUFBVTtFQUFBLEVBQUMsRUFBRTtJQUN0RCxJQUFNQyxTQUFTLEdBQUdILEtBQUssQ0FBQ0ksR0FBRyxDQUN6QixVQUFDRixJQUFJO01BQUEsT0FBSyxPQUFPQSxJQUFJLEtBQUssVUFBVSxlQUFBMUIsTUFBQSxDQUFlMEIsSUFBSSxDQUFDRyxJQUFJLElBQUksU0FBUyxVQUFBVixPQUFBLENBQWNPLElBQUk7SUFBQSxDQUM3RixDQUFDLENBQUNJLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDWixNQUFNLElBQUlWLFNBQVMsSUFBQXBCLE1BQUEsQ0FBSWlCLFlBQVksT0FBQWpCLE1BQUEsQ0FBSTJCLFNBQVMsTUFBRyxDQUFDO0VBQ3REO0FBQ0Y7QUFDQSxJQUFJSSxhQUFhLEdBQUcsU0FBaEJBLGFBQWFBLENBQUlMLElBQUksRUFBSztFQUM1QixPQUFPTSxLQUFLLENBQUNDLE9BQU8sQ0FBQ1AsSUFBSSxDQUFDLEdBQUdBLElBQUksR0FBRyxDQUFDQSxJQUFJLENBQUM7QUFDNUMsQ0FBQztBQUNELFNBQVNRLGVBQWVBLENBQUNDLGtCQUFrQixFQUFFO0VBQzNDLElBQU1DLFlBQVksR0FBR0osS0FBSyxDQUFDQyxPQUFPLENBQUNFLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUdBLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHQSxrQkFBa0I7RUFDdEdaLHdCQUF3QixDQUN0QmEsWUFBWSxrR0FFZCxDQUFDO0VBQ0QsT0FBT0EsWUFBWTtBQUNyQjtBQUNBLFNBQVNDLDJCQUEyQkEsQ0FBQ0QsWUFBWSxFQUFFM0MsaUJBQWlCLEVBQUU7RUFDcEUsSUFBTUcsb0JBQW9CLEdBQUcsRUFBRTtFQUMvQixJQUFRZixNQUFNLEdBQUt1RCxZQUFZLENBQXZCdkQsTUFBTTtFQUNkLEtBQUssSUFBSXlELENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3pELE1BQU0sRUFBRXlELENBQUMsRUFBRSxFQUFFO0lBQy9CMUMsb0JBQW9CLENBQUMyQyxJQUFJLENBQUNILFlBQVksQ0FBQ0UsQ0FBQyxDQUFDLENBQUN2QyxLQUFLLENBQUMsSUFBSSxFQUFFTixpQkFBaUIsQ0FBQyxDQUFDO0VBQzNFO0VBQ0EsT0FBT0csb0JBQW9CO0FBQzdCO0FBQ0EsSUFBSTRDLDZCQUE2QixHQUFHLFNBQWhDQSw2QkFBNkJBLENBQUlDLFFBQVEsRUFBRS9CLGFBQWEsRUFBSztFQUMvRCxJQUFBZ0MscUJBQUEsR0FBQUMsYUFBQSxDQUFBQSxhQUFBLEtBQ0tyQyxtQkFBbUIsR0FDbkJJLGFBQWE7SUFGVkYscUJBQXFCLEdBQUFrQyxxQkFBQSxDQUFyQmxDLHFCQUFxQjtJQUFFRCxtQkFBbUIsR0FBQW1DLHFCQUFBLENBQW5CbkMsbUJBQW1CO0VBSWxELE9BQU87SUFDTEMscUJBQXFCLEVBQUU7TUFDckJvQyxTQUFTLEVBQUVwQyxxQkFBcUIsS0FBSyxRQUFRLElBQUlBLHFCQUFxQixLQUFLLE1BQU0sSUFBSWlDLFFBQVE7TUFDN0ZJLEdBQUcsRUFBRXBFO0lBQ1AsQ0FBQztJQUNEOEIsbUJBQW1CLEVBQUU7TUFDbkJxQyxTQUFTLEVBQUVyQyxtQkFBbUIsS0FBSyxRQUFRLElBQUlBLG1CQUFtQixLQUFLLE1BQU0sSUFBSWtDLFFBQVE7TUFDekZJLEdBQUcsRUFBRXZEO0lBQ1A7RUFDRixDQUFDO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLElBQUl3RCxTQUFTLEdBQUcsQ0FBQztBQUNqQixJQUFJQyxlQUFlLEdBQUcsSUFBSTtBQUMxQixJQUFJQyxJQUFJO0VBS04sU0FBQUEsS0FBWUMsWUFBWSxFQUFzQjtJQUFBLElBQXBCQyxPQUFPLEdBQUEvQyxTQUFBLENBQUF0QixNQUFBLFFBQUFzQixTQUFBLFFBQUFlLFNBQUEsR0FBQWYsU0FBQSxNQUFHZ0QsUUFBUTtJQUFBQyxlQUFBLE9BQUFKLElBQUE7SUFBQSxLQUo1Q0ssUUFBUSxHQUFHUCxTQUFTO0lBQUEsS0FDcEJRLE1BQU07SUFBQSxLQUNOQyxVQUFVO0lBQUEsS0FDVkMsUUFBUSxHQUFHTCxRQUFRO0lBRWpCLElBQUksQ0FBQ0csTUFBTSxHQUFHLElBQUksQ0FBQ0MsVUFBVSxHQUFHTixZQUFZO0lBQzVDLElBQUksQ0FBQ08sUUFBUSxHQUFHTixPQUFPO0VBQ3pCO0VBQ0E7RUFDQTtFQUFBLE9BQUFPLFlBQUEsQ0FBQVQsSUFBQTtJQUFBVSxHQUFBO0lBQUFDLEdBQUEsRUFDQSxTQUFBQSxJQUFBLEVBQVk7TUFBQSxJQUFBQyxnQkFBQTtNQUNWLENBQUFBLGdCQUFBLEdBQUFiLGVBQWUsY0FBQWEsZ0JBQUEsZUFBZkEsZ0JBQUEsQ0FBaUJDLEdBQUcsQ0FBQyxJQUFJLENBQUM7TUFDMUIsT0FBTyxJQUFJLENBQUNQLE1BQU07SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQUE7SUFBQVEsR0FBQSxFQUNBLFNBQUFBLElBQVVDLFFBQVEsRUFBRTtNQUNsQixJQUFJLElBQUksQ0FBQ0MsS0FBSyxLQUFLRCxRQUFRLEVBQ3pCO01BQ0YsSUFBSSxDQUFDVCxNQUFNLEdBQUdTLFFBQVE7TUFDdEIsSUFBSSxDQUFDVixRQUFRLEdBQUcsRUFBRVAsU0FBUztJQUM3QjtFQUFDO0FBQUEsR0FDRjtBQUNELFNBQVNLLFFBQVFBLENBQUNjLENBQUMsRUFBRUMsQ0FBQyxFQUFFO0VBQ3RCLE9BQU9ELENBQUMsS0FBS0MsQ0FBQztBQUNoQjtBQUNBLElBQUlDLGFBQWE7RUFNZixTQUFBQSxjQUFZQyxFQUFFLEVBQUU7SUFBQWhCLGVBQUEsT0FBQWUsYUFBQTtJQUFBLEtBTGhCRSxZQUFZO0lBQUEsS0FDWkMsZUFBZSxHQUFHLENBQUMsQ0FBQztJQUFBLEtBQ3BCQyxLQUFLLEdBQUcsRUFBRTtJQUFBLEtBQ1ZDLElBQUksR0FBRyxDQUFDO0lBQUEsS0FDUkosRUFBRTtJQUVBLElBQUksQ0FBQ0EsRUFBRSxHQUFHQSxFQUFFO0VBQ2Q7RUFBQyxPQUFBWCxZQUFBLENBQUFVLGFBQUE7SUFBQVQsR0FBQTtJQUFBTSxLQUFBLEVBQ0QsU0FBQVMsS0FBS0EsQ0FBQSxFQUFHO01BQ04sSUFBSSxDQUFDSixZQUFZLEdBQUcsS0FBSyxDQUFDO01BQzFCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLENBQUMsQ0FBQztNQUN6QixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO01BQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQztJQUNmO0VBQUM7SUFBQWQsR0FBQTtJQUFBQyxHQUFBLEVBQ0QsU0FBQUEsSUFBQSxFQUFZO01BQUEsSUFBQWUsaUJBQUE7TUFDVixJQUFJLElBQUksQ0FBQ3JCLFFBQVEsR0FBRyxJQUFJLENBQUNpQixlQUFlLEVBQUU7UUFDeEMsSUFBUUYsRUFBRSxHQUFLLElBQUksQ0FBWEEsRUFBRTtRQUNWLElBQU1PLGNBQWMsR0FBRyxlQUFnQixJQUFJQyxHQUFHLENBQUMsQ0FBQztRQUNoRCxJQUFNQyxXQUFXLEdBQUc5QixlQUFlO1FBQ25DQSxlQUFlLEdBQUc0QixjQUFjO1FBQ2hDLElBQUksQ0FBQ04sWUFBWSxHQUFHRCxFQUFFLENBQUMsQ0FBQztRQUN4QnJCLGVBQWUsR0FBRzhCLFdBQVc7UUFDN0IsSUFBSSxDQUFDTCxJQUFJLEVBQUU7UUFDWCxJQUFJLENBQUNELEtBQUssR0FBR3ZDLEtBQUssQ0FBQzhDLElBQUksQ0FBQ0gsY0FBYyxDQUFDO1FBQ3ZDLElBQUksQ0FBQ0wsZUFBZSxHQUFHLElBQUksQ0FBQ2pCLFFBQVE7TUFDdEM7TUFDQSxDQUFBcUIsaUJBQUEsR0FBQTNCLGVBQWUsY0FBQTJCLGlCQUFBLGVBQWZBLGlCQUFBLENBQWlCYixHQUFHLENBQUMsSUFBSSxDQUFDO01BQzFCLE9BQU8sSUFBSSxDQUFDUSxZQUFZO0lBQzFCO0VBQUM7SUFBQVgsR0FBQTtJQUFBQyxHQUFBLEVBQ0QsU0FBQUEsSUFBQSxFQUFlO01BQ2IsT0FBT29CLElBQUksQ0FBQ0MsR0FBRyxDQUFBakYsS0FBQSxDQUFSZ0YsSUFBSSxFQUFBOUUsa0JBQUEsQ0FBUSxJQUFJLENBQUNzRSxLQUFLLENBQUMzQyxHQUFHLENBQUMsVUFBQ3FELENBQUM7UUFBQSxPQUFLQSxDQUFDLENBQUM1QixRQUFRO01BQUEsRUFBQyxFQUFBckQsTUFBQSxFQUFFLENBQUMsR0FBQztJQUMxRDtFQUFDO0FBQUEsR0FDRjtBQUNELFNBQVNrRixRQUFRQSxDQUFDQyxJQUFJLEVBQUU7RUFDdEIsSUFBSSxFQUFFQSxJQUFJLFlBQVluQyxJQUFJLENBQUMsRUFBRTtJQUMzQjVELE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLG9CQUFvQixFQUFFOEYsSUFBSSxDQUFDO0VBQzFDO0VBQ0EsT0FBT0EsSUFBSSxDQUFDbkIsS0FBSztBQUNuQjtBQUNBLFNBQVNvQixRQUFRQSxDQUFDQyxPQUFPLEVBQUVyQixLQUFLLEVBQUU7RUFDaEMsSUFBSSxFQUFFcUIsT0FBTyxZQUFZckMsSUFBSSxDQUFDLEVBQUU7SUFDOUIsTUFBTSxJQUFJNUIsU0FBUyxDQUNqQix1RUFDRixDQUFDO0VBQ0g7RUFDQWlFLE9BQU8sQ0FBQ3JCLEtBQUssR0FBR3FCLE9BQU8sQ0FBQzlCLFVBQVUsR0FBR1MsS0FBSztBQUM1QztBQUNBLFNBQVNzQixVQUFVQSxDQUFDckMsWUFBWSxFQUFzQjtFQUFBLElBQXBCQyxPQUFPLEdBQUEvQyxTQUFBLENBQUF0QixNQUFBLFFBQUFzQixTQUFBLFFBQUFlLFNBQUEsR0FBQWYsU0FBQSxNQUFHZ0QsUUFBUTtFQUNsRCxPQUFPLElBQUlILElBQUksQ0FBQ0MsWUFBWSxFQUFFQyxPQUFPLENBQUM7QUFDeEM7QUFDQSxTQUFTcUMsV0FBV0EsQ0FBQ25CLEVBQUUsRUFBRTtFQUN2QnJELGdCQUFnQixDQUNkcUQsRUFBRSxFQUNGLHlEQUNGLENBQUM7RUFDRCxPQUFPLElBQUlELGFBQWEsQ0FBQ0MsRUFBRSxDQUFDO0FBQzlCOztBQUVBO0FBQ0EsSUFBSW9CLE9BQU8sR0FBRyxTQUFWQSxPQUFPQSxDQUFJdkIsQ0FBQyxFQUFFQyxDQUFDO0VBQUEsT0FBSyxLQUFLO0FBQUE7QUFDN0IsU0FBU3VCLFNBQVNBLENBQUEsRUFBRztFQUNuQixPQUFPSCxVQUFVLENBQUMsSUFBSSxFQUFFRSxPQUFPLENBQUM7QUFDbEM7QUFDQSxTQUFTRSxRQUFRQSxDQUFDQyxHQUFHLEVBQUUzQixLQUFLLEVBQUU7RUFDNUJvQixRQUFRLENBQUNPLEdBQUcsRUFBRTNCLEtBQUssQ0FBQztBQUN0QjtBQUNBLElBQUk0QixpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQWlCQSxDQUFJQyxJQUFJLEVBQUs7RUFDaEMsSUFBSUYsR0FBRyxHQUFHRSxJQUFJLENBQUNDLGFBQWE7RUFDNUIsSUFBSUgsR0FBRyxLQUFLLElBQUksRUFBRTtJQUNoQkEsR0FBRyxHQUFHRSxJQUFJLENBQUNDLGFBQWEsR0FBR0wsU0FBUyxDQUFDLENBQUM7RUFDeEM7RUFDQVAsUUFBUSxDQUFDUyxHQUFHLENBQUM7QUFDZixDQUFDO0FBQ0QsSUFBSUksZUFBZSxHQUFHLFNBQWxCQSxlQUFlQSxDQUFJRixJQUFJLEVBQUs7RUFDOUIsSUFBTUYsR0FBRyxHQUFHRSxJQUFJLENBQUNDLGFBQWE7RUFDOUIsSUFBSUgsR0FBRyxLQUFLLElBQUksRUFBRTtJQUNoQkQsUUFBUSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDO0VBQ3JCO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBLElBQUlLLGlCQUFpQixHQUFHbEYsTUFBTSxDQUFDLENBQUM7QUFDaEMsSUFBSW1GLE1BQU0sR0FBRyxDQUFDO0FBQ2QsSUFBSUMsS0FBSyxHQUFHdkYsTUFBTSxDQUFDd0YsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLElBQUlDLGNBQWMsZ0JBQUEzQyxZQUFBLENBQ2hCLFNBQUEyQyxlQUFZcEMsS0FBSyxFQUFFO0VBQUFaLGVBQUEsT0FBQWdELGNBQUE7RUFBQSxLQUtuQkMsS0FBSyxHQUFHLElBQUlDLEtBQUssQ0FBQyxJQUFJLEVBQUVDLGtCQUFrQixDQUFDO0VBQUEsS0FDM0NaLEdBQUcsR0FBR0YsU0FBUyxDQUFDLENBQUM7RUFBQSxLQUNqQmUsSUFBSSxHQUFHLENBQUMsQ0FBQztFQUFBLEtBQ1RDLFFBQVEsR0FBRyxDQUFDLENBQUM7RUFBQSxLQUNiWCxhQUFhLEdBQUcsSUFBSTtFQUFBLEtBQ3BCWSxFQUFFLEdBQUdULE1BQU0sRUFBRTtFQVRYLElBQUksQ0FBQ2pDLEtBQUssR0FBR0EsS0FBSztFQUNsQixJQUFJLENBQUNBLEtBQUssR0FBR0EsS0FBSztFQUNsQixJQUFJLENBQUMyQixHQUFHLENBQUMzQixLQUFLLEdBQUdBLEtBQUs7QUFDeEIsQ0FBQyxDQU9GO0FBQ0QsSUFBSXVDLGtCQUFrQixHQUFHO0VBQ3ZCNUMsR0FBRyxXQUFIQSxHQUFHQSxDQUFDa0MsSUFBSSxFQUFFbkMsR0FBRyxFQUFFO0lBQ2IsU0FBU2lELGVBQWVBLENBQUEsRUFBRztNQUN6QixJQUFRM0MsS0FBSyxHQUFLNkIsSUFBSSxDQUFkN0IsS0FBSztNQUNiLElBQU00QyxVQUFVLEdBQUdDLE9BQU8sQ0FBQ2xELEdBQUcsQ0FBQ0ssS0FBSyxFQUFFTixHQUFHLENBQUM7TUFDMUMsSUFBSXZDLE9BQUEsQ0FBT3VDLEdBQUcsTUFBSyxRQUFRLEVBQUU7UUFDM0IsT0FBT2tELFVBQVU7TUFDbkI7TUFDQSxJQUFJbEQsR0FBRyxJQUFJd0MsS0FBSyxFQUFFO1FBQ2hCLE9BQU9VLFVBQVU7TUFDbkI7TUFDQSxJQUFJekYsT0FBQSxDQUFPeUYsVUFBVSxNQUFLLFFBQVEsSUFBSUEsVUFBVSxLQUFLLElBQUksRUFBRTtRQUN6RCxJQUFJRSxTQUFTLEdBQUdqQixJQUFJLENBQUNZLFFBQVEsQ0FBQy9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJb0QsU0FBUyxLQUFLLEtBQUssQ0FBQyxFQUFFO1VBQ3hCQSxTQUFTLEdBQUdqQixJQUFJLENBQUNZLFFBQVEsQ0FBQy9DLEdBQUcsQ0FBQyxHQUFHcUQsVUFBVSxDQUFDSCxVQUFVLENBQUM7UUFDekQ7UUFDQSxJQUFJRSxTQUFTLENBQUNuQixHQUFHLEVBQUU7VUFDakJULFFBQVEsQ0FBQzRCLFNBQVMsQ0FBQ25CLEdBQUcsQ0FBQztRQUN6QjtRQUNBLE9BQU9tQixTQUFTLENBQUNULEtBQUs7TUFDeEIsQ0FBQyxNQUFNO1FBQ0wsSUFBSVYsR0FBRyxHQUFHRSxJQUFJLENBQUNXLElBQUksQ0FBQzlDLEdBQUcsQ0FBQztRQUN4QixJQUFJaUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxFQUFFO1VBQ2xCQSxHQUFHLEdBQUdFLElBQUksQ0FBQ1csSUFBSSxDQUFDOUMsR0FBRyxDQUFDLEdBQUcrQixTQUFTLENBQUMsQ0FBQztVQUNsQ0UsR0FBRyxDQUFDM0IsS0FBSyxHQUFHNEMsVUFBVTtRQUN4QjtRQUNBMUIsUUFBUSxDQUFDUyxHQUFHLENBQUM7UUFDYixPQUFPaUIsVUFBVTtNQUNuQjtJQUNGO0lBQ0EsSUFBTUksR0FBRyxHQUFHTCxlQUFlLENBQUMsQ0FBQztJQUM3QixPQUFPSyxHQUFHO0VBQ1osQ0FBQztFQUNEQyxPQUFPLFdBQVBBLE9BQU9BLENBQUNwQixJQUFJLEVBQUU7SUFDWkQsaUJBQWlCLENBQUNDLElBQUksQ0FBQztJQUN2QixPQUFPZ0IsT0FBTyxDQUFDSSxPQUFPLENBQUNwQixJQUFJLENBQUM3QixLQUFLLENBQUM7RUFDcEMsQ0FBQztFQUNEa0Qsd0JBQXdCLFdBQXhCQSx3QkFBd0JBLENBQUNyQixJQUFJLEVBQUVzQixJQUFJLEVBQUU7SUFDbkMsT0FBT04sT0FBTyxDQUFDSyx3QkFBd0IsQ0FBQ3JCLElBQUksQ0FBQzdCLEtBQUssRUFBRW1ELElBQUksQ0FBQztFQUMzRCxDQUFDO0VBQ0RDLEdBQUcsV0FBSEEsR0FBR0EsQ0FBQ3ZCLElBQUksRUFBRXNCLElBQUksRUFBRTtJQUNkLE9BQU9OLE9BQU8sQ0FBQ08sR0FBRyxDQUFDdkIsSUFBSSxDQUFDN0IsS0FBSyxFQUFFbUQsSUFBSSxDQUFDO0VBQ3RDO0FBQ0YsQ0FBQztBQUNELElBQUlFLGFBQWEsZ0JBQUE1RCxZQUFBLENBQ2YsU0FBQTRELGNBQVlyRCxLQUFLLEVBQUU7RUFBQVosZUFBQSxPQUFBaUUsYUFBQTtFQUFBLEtBS25CaEIsS0FBSyxHQUFHLElBQUlDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFZ0IsaUJBQWlCLENBQUM7RUFBQSxLQUM1QzNCLEdBQUcsR0FBR0YsU0FBUyxDQUFDLENBQUM7RUFBQSxLQUNqQmUsSUFBSSxHQUFHLENBQUMsQ0FBQztFQUFBLEtBQ1RDLFFBQVEsR0FBRyxDQUFDLENBQUM7RUFBQSxLQUNiWCxhQUFhLEdBQUcsSUFBSTtFQUFBLEtBQ3BCWSxFQUFFLEdBQUdULE1BQU0sRUFBRTtFQVRYLElBQUksQ0FBQ2pDLEtBQUssR0FBR0EsS0FBSztFQUNsQixJQUFJLENBQUNBLEtBQUssR0FBR0EsS0FBSztFQUNsQixJQUFJLENBQUMyQixHQUFHLENBQUMzQixLQUFLLEdBQUdBLEtBQUs7QUFDeEIsQ0FBQyxDQU9GO0FBQ0QsSUFBSXNELGlCQUFpQixHQUFHO0VBQ3RCM0QsR0FBRyxXQUFIQSxHQUFHQSxDQUFBNEQsSUFBQSxFQUFTN0QsR0FBRyxFQUFFO0lBQUEsSUFBQThELEtBQUEsR0FBQUMsY0FBQSxDQUFBRixJQUFBO01BQVoxQixJQUFJLEdBQUEyQixLQUFBO0lBQ1AsSUFBSTlELEdBQUcsS0FBSyxRQUFRLEVBQUU7TUFDcEJrQyxpQkFBaUIsQ0FBQ0MsSUFBSSxDQUFDO0lBQ3pCO0lBQ0EsT0FBT1Usa0JBQWtCLENBQUM1QyxHQUFHLENBQUNrQyxJQUFJLEVBQUVuQyxHQUFHLENBQUM7RUFDMUMsQ0FBQztFQUNEdUQsT0FBTyxXQUFQQSxPQUFPQSxDQUFBUyxLQUFBLEVBQVM7SUFBQSxJQUFBQyxLQUFBLEdBQUFGLGNBQUEsQ0FBQUMsS0FBQTtNQUFQN0IsSUFBSSxHQUFBOEIsS0FBQTtJQUNYLE9BQU9wQixrQkFBa0IsQ0FBQ1UsT0FBTyxDQUFDcEIsSUFBSSxDQUFDO0VBQ3pDLENBQUM7RUFDRHFCLHdCQUF3QixXQUF4QkEsd0JBQXdCQSxDQUFBVSxLQUFBLEVBQVNULElBQUksRUFBRTtJQUFBLElBQUFVLEtBQUEsR0FBQUosY0FBQSxDQUFBRyxLQUFBO01BQWIvQixJQUFJLEdBQUFnQyxLQUFBO0lBQzVCLE9BQU90QixrQkFBa0IsQ0FBQ1csd0JBQXdCLENBQUNyQixJQUFJLEVBQUVzQixJQUFJLENBQUM7RUFDaEUsQ0FBQztFQUNEQyxHQUFHLFdBQUhBLEdBQUdBLENBQUFVLEtBQUEsRUFBU1gsSUFBSSxFQUFFO0lBQUEsSUFBQVksS0FBQSxHQUFBTixjQUFBLENBQUFLLEtBQUE7TUFBYmpDLElBQUksR0FBQWtDLEtBQUE7SUFDUCxPQUFPeEIsa0JBQWtCLENBQUNhLEdBQUcsQ0FBQ3ZCLElBQUksRUFBRXNCLElBQUksQ0FBQztFQUMzQztBQUNGLENBQUM7QUFDRCxTQUFTSixVQUFVQSxDQUFDL0MsS0FBSyxFQUFFO0VBQ3pCLElBQUloQyxLQUFLLENBQUNDLE9BQU8sQ0FBQytCLEtBQUssQ0FBQyxFQUFFO0lBQ3hCLE9BQU8sSUFBSXFELGFBQWEsQ0FBQ3JELEtBQUssQ0FBQztFQUNqQztFQUNBLE9BQU8sSUFBSW9DLGNBQWMsQ0FBQ3BDLEtBQUssQ0FBQztBQUNsQztBQUNBLFNBQVNnRSxVQUFVQSxDQUFDbkMsSUFBSSxFQUFFOUIsUUFBUSxFQUFFO0VBQ2xDLElBQVFDLEtBQUssR0FBcUI2QixJQUFJLENBQTlCN0IsS0FBSztJQUFFd0MsSUFBSSxHQUFlWCxJQUFJLENBQXZCVyxJQUFJO0lBQUVDLFFBQVEsR0FBS1osSUFBSSxDQUFqQlksUUFBUTtFQUM3QlosSUFBSSxDQUFDN0IsS0FBSyxHQUFHRCxRQUFRO0VBQ3JCLElBQUkvQixLQUFLLENBQUNDLE9BQU8sQ0FBQytCLEtBQUssQ0FBQyxJQUFJaEMsS0FBSyxDQUFDQyxPQUFPLENBQUM4QixRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDbkYsTUFBTSxLQUFLa0YsUUFBUSxDQUFDbEYsTUFBTSxFQUFFO0lBQ3ZGa0gsZUFBZSxDQUFDRixJQUFJLENBQUM7RUFDdkIsQ0FBQyxNQUFNO0lBQ0wsSUFBSTdCLEtBQUssS0FBS0QsUUFBUSxFQUFFO01BQ3RCLElBQUlrRSxXQUFXLEdBQUcsQ0FBQztNQUNuQixJQUFJQyxXQUFXLEdBQUcsQ0FBQztNQUNuQixJQUFJQyxZQUFZLEdBQUcsS0FBSztNQUN4QixLQUFLLElBQU1DLElBQUksSUFBSXBFLEtBQUssRUFBRTtRQUN4QmlFLFdBQVcsRUFBRTtNQUNmO01BQ0EsS0FBSyxJQUFNdkUsR0FBRyxJQUFJSyxRQUFRLEVBQUU7UUFDMUJtRSxXQUFXLEVBQUU7UUFDYixJQUFJLEVBQUV4RSxHQUFHLElBQUlNLEtBQUssQ0FBQyxFQUFFO1VBQ25CbUUsWUFBWSxHQUFHLElBQUk7VUFDbkI7UUFDRjtNQUNGO01BQ0EsSUFBTUUsV0FBVyxHQUFHRixZQUFZLElBQUlGLFdBQVcsS0FBS0MsV0FBVztNQUMvRCxJQUFJRyxXQUFXLEVBQUU7UUFDZnRDLGVBQWUsQ0FBQ0YsSUFBSSxDQUFDO01BQ3ZCO0lBQ0Y7RUFDRjtFQUNBLEtBQUssSUFBTW5DLEtBQUcsSUFBSThDLElBQUksRUFBRTtJQUN0QixJQUFNSSxVQUFVLEdBQUc1QyxLQUFLLENBQUNOLEtBQUcsQ0FBQztJQUM3QixJQUFNNEUsYUFBYSxHQUFHdkUsUUFBUSxDQUFDTCxLQUFHLENBQUM7SUFDbkMsSUFBSWtELFVBQVUsS0FBSzBCLGFBQWEsRUFBRTtNQUNoQ3ZDLGVBQWUsQ0FBQ0YsSUFBSSxDQUFDO01BQ3JCSCxRQUFRLENBQUNjLElBQUksQ0FBQzlDLEtBQUcsQ0FBQyxFQUFFNEUsYUFBYSxDQUFDO0lBQ3BDO0lBQ0EsSUFBSW5ILE9BQUEsQ0FBT21ILGFBQWEsTUFBSyxRQUFRLElBQUlBLGFBQWEsS0FBSyxJQUFJLEVBQUU7TUFDL0QsT0FBTzlCLElBQUksQ0FBQzlDLEtBQUcsQ0FBQztJQUNsQjtFQUNGO0VBQ0EsS0FBSyxJQUFNQSxLQUFHLElBQUkrQyxRQUFRLEVBQUU7SUFDMUIsSUFBTUssU0FBUyxHQUFHTCxRQUFRLENBQUMvQyxLQUFHLENBQUM7SUFDL0IsSUFBTTRFLGNBQWEsR0FBR3ZFLFFBQVEsQ0FBQ0wsS0FBRyxDQUFDO0lBQ25DLElBQU1rRCxXQUFVLEdBQUdFLFNBQVMsQ0FBQzlDLEtBQUs7SUFDbEMsSUFBSTRDLFdBQVUsS0FBSzBCLGNBQWEsRUFBRTtNQUNoQztJQUNGLENBQUMsTUFBTSxJQUFJbkgsT0FBQSxDQUFPbUgsY0FBYSxNQUFLLFFBQVEsSUFBSUEsY0FBYSxLQUFLLElBQUksRUFBRTtNQUN0RU4sVUFBVSxDQUFDbEIsU0FBUyxFQUFFd0IsY0FBYSxDQUFDO0lBQ3RDLENBQUMsTUFBTTtNQUNMQyxVQUFVLENBQUN6QixTQUFTLENBQUM7TUFDckIsT0FBT0wsUUFBUSxDQUFDL0MsS0FBRyxDQUFDO0lBQ3RCO0VBQ0Y7QUFDRjtBQUNBLFNBQVM2RSxVQUFVQSxDQUFDMUMsSUFBSSxFQUFFO0VBQ3hCLElBQUlBLElBQUksQ0FBQ0YsR0FBRyxFQUFFO0lBQ1pELFFBQVEsQ0FBQ0csSUFBSSxDQUFDRixHQUFHLEVBQUUsSUFBSSxDQUFDO0VBQzFCO0VBQ0FJLGVBQWUsQ0FBQ0YsSUFBSSxDQUFDO0VBQ3JCLEtBQUssSUFBTW5DLEdBQUcsSUFBSW1DLElBQUksQ0FBQ1csSUFBSSxFQUFFO0lBQzNCZCxRQUFRLENBQUNHLElBQUksQ0FBQ1csSUFBSSxDQUFDOUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDO0VBQ2hDO0VBQ0EsS0FBSyxJQUFNQSxLQUFHLElBQUltQyxJQUFJLENBQUNZLFFBQVEsRUFBRTtJQUMvQjhCLFVBQVUsQ0FBQzFDLElBQUksQ0FBQ1ksUUFBUSxDQUFDL0MsS0FBRyxDQUFDLENBQUM7RUFDaEM7QUFDRjs7QUFFQTtBQUNBLFNBQVM4RSxvQkFBb0JBLENBQUNDLE1BQU0sRUFBRTtFQUNwQyxJQUFJQyxLQUFLO0VBQ1QsT0FBTztJQUNML0UsR0FBRyxXQUFIQSxHQUFHQSxDQUFDRCxHQUFHLEVBQUU7TUFDUCxJQUFJZ0YsS0FBSyxJQUFJRCxNQUFNLENBQUNDLEtBQUssQ0FBQ2hGLEdBQUcsRUFBRUEsR0FBRyxDQUFDLEVBQUU7UUFDbkMsT0FBT2dGLEtBQUssQ0FBQzFFLEtBQUs7TUFDcEI7TUFDQSxPQUFPbkQsU0FBUztJQUNsQixDQUFDO0lBQ0Q4SCxHQUFHLFdBQUhBLEdBQUdBLENBQUNqRixHQUFHLEVBQUVNLEtBQUssRUFBRTtNQUNkMEUsS0FBSyxHQUFHO1FBQUVoRixHQUFHLEVBQUhBLEdBQUc7UUFBRU0sS0FBSyxFQUFMQTtNQUFNLENBQUM7SUFDeEIsQ0FBQztJQUNENEUsVUFBVSxXQUFWQSxVQUFVQSxDQUFBLEVBQUc7TUFDWCxPQUFPRixLQUFLLEdBQUcsQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsRUFBRTtJQUM3QixDQUFDO0lBQ0RqRSxLQUFLLFdBQUxBLEtBQUtBLENBQUEsRUFBRztNQUNOaUUsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNoQjtFQUNGLENBQUM7QUFDSDtBQUNBLFNBQVNHLGNBQWNBLENBQUNDLE9BQU8sRUFBRUwsTUFBTSxFQUFFO0VBQ3ZDLElBQUlNLE9BQU8sR0FBRyxFQUFFO0VBQ2hCLFNBQVNwRixHQUFHQSxDQUFDRCxHQUFHLEVBQUU7SUFDaEIsSUFBTXNGLFVBQVUsR0FBR0QsT0FBTyxDQUFDRSxTQUFTLENBQUMsVUFBQ1AsS0FBSztNQUFBLE9BQUtELE1BQU0sQ0FBQy9FLEdBQUcsRUFBRWdGLEtBQUssQ0FBQ2hGLEdBQUcsQ0FBQztJQUFBLEVBQUM7SUFDdkUsSUFBSXNGLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRTtNQUNuQixJQUFNTixLQUFLLEdBQUdLLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDO01BQ2pDLElBQUlBLFVBQVUsR0FBRyxDQUFDLEVBQUU7UUFDbEJELE9BQU8sQ0FBQ0csTUFBTSxDQUFDRixVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQzdCRCxPQUFPLENBQUNJLE9BQU8sQ0FBQ1QsS0FBSyxDQUFDO01BQ3hCO01BQ0EsT0FBT0EsS0FBSyxDQUFDMUUsS0FBSztJQUNwQjtJQUNBLE9BQU9uRCxTQUFTO0VBQ2xCO0VBQ0EsU0FBUzhILEdBQUdBLENBQUNqRixHQUFHLEVBQUVNLEtBQUssRUFBRTtJQUN2QixJQUFJTCxHQUFHLENBQUNELEdBQUcsQ0FBQyxLQUFLN0MsU0FBUyxFQUFFO01BQzFCa0ksT0FBTyxDQUFDSSxPQUFPLENBQUM7UUFBRXpGLEdBQUcsRUFBSEEsR0FBRztRQUFFTSxLQUFLLEVBQUxBO01BQU0sQ0FBQyxDQUFDO01BQy9CLElBQUkrRSxPQUFPLENBQUNsSyxNQUFNLEdBQUdpSyxPQUFPLEVBQUU7UUFDNUJDLE9BQU8sQ0FBQ0ssR0FBRyxDQUFDLENBQUM7TUFDZjtJQUNGO0VBQ0Y7RUFDQSxTQUFTUixVQUFVQSxDQUFBLEVBQUc7SUFDcEIsT0FBT0csT0FBTztFQUNoQjtFQUNBLFNBQVN0RSxLQUFLQSxDQUFBLEVBQUc7SUFDZnNFLE9BQU8sR0FBRyxFQUFFO0VBQ2Q7RUFDQSxPQUFPO0lBQUVwRixHQUFHLEVBQUhBLEdBQUc7SUFBRWdGLEdBQUcsRUFBSEEsR0FBRztJQUFFQyxVQUFVLEVBQVZBLFVBQVU7SUFBRW5FLEtBQUssRUFBTEE7RUFBTSxDQUFDO0FBQ3hDO0FBQ0EsSUFBSTRFLHNCQUFzQixHQUFHLFNBQXpCQSxzQkFBc0JBLENBQUlwRixDQUFDLEVBQUVDLENBQUM7RUFBQSxPQUFLRCxDQUFDLEtBQUtDLENBQUM7QUFBQTtBQUM5QyxTQUFTb0Ysd0JBQXdCQSxDQUFDQyxhQUFhLEVBQUU7RUFDL0MsT0FBTyxTQUFTQywwQkFBMEJBLENBQUNDLElBQUksRUFBRUMsSUFBSSxFQUFFO0lBQ3JELElBQUlELElBQUksS0FBSyxJQUFJLElBQUlDLElBQUksS0FBSyxJQUFJLElBQUlELElBQUksQ0FBQzVLLE1BQU0sS0FBSzZLLElBQUksQ0FBQzdLLE1BQU0sRUFBRTtNQUNqRSxPQUFPLEtBQUs7SUFDZDtJQUNBLElBQVFBLE1BQU0sR0FBSzRLLElBQUksQ0FBZjVLLE1BQU07SUFDZCxLQUFLLElBQUl5RCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd6RCxNQUFNLEVBQUV5RCxDQUFDLEVBQUUsRUFBRTtNQUMvQixJQUFJLENBQUNpSCxhQUFhLENBQUNFLElBQUksQ0FBQ25ILENBQUMsQ0FBQyxFQUFFb0gsSUFBSSxDQUFDcEgsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNwQyxPQUFPLEtBQUs7TUFDZDtJQUNGO0lBQ0EsT0FBTyxJQUFJO0VBQ2IsQ0FBQztBQUNIO0FBQ0EsU0FBU3FILFVBQVVBLENBQUMzSSxJQUFJLEVBQUU0SSxzQkFBc0IsRUFBRTtFQUNoRCxJQUFNQyxlQUFlLEdBQUcxSSxPQUFBLENBQU95SSxzQkFBc0IsTUFBSyxRQUFRLEdBQUdBLHNCQUFzQixHQUFHO0lBQUVMLGFBQWEsRUFBRUs7RUFBdUIsQ0FBQztFQUN2SSxJQUFBRSxxQkFBQSxHQUlJRCxlQUFlLENBSGpCTixhQUFhO0lBQWJBLGFBQWEsR0FBQU8scUJBQUEsY0FBR1Qsc0JBQXNCLEdBQUFTLHFCQUFBO0lBQUFDLHFCQUFBLEdBR3BDRixlQUFlLENBRmpCZixPQUFPO0lBQVBBLE9BQU8sR0FBQWlCLHFCQUFBLGNBQUcsQ0FBQyxHQUFBQSxxQkFBQTtJQUNYQyxtQkFBbUIsR0FDakJILGVBQWUsQ0FEakJHLG1CQUFtQjtFQUVyQixJQUFNQyxVQUFVLEdBQUdYLHdCQUF3QixDQUFDQyxhQUFhLENBQUM7RUFDMUQsSUFBSVcsWUFBWSxHQUFHLENBQUM7RUFDcEIsSUFBTUMsS0FBSyxHQUFHckIsT0FBTyxJQUFJLENBQUMsR0FBR04sb0JBQW9CLENBQUN5QixVQUFVLENBQUMsR0FBR3BCLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFbUIsVUFBVSxDQUFDO0VBQ25HLFNBQVNHLFFBQVFBLENBQUEsRUFBRztJQUNsQixJQUFJcEcsS0FBSyxHQUFHbUcsS0FBSyxDQUFDeEcsR0FBRyxDQUFDeEQsU0FBUyxDQUFDO0lBQ2hDLElBQUk2RCxLQUFLLEtBQUtuRCxTQUFTLEVBQUU7TUFDdkJtRCxLQUFLLEdBQUdoRCxJQUFJLENBQUNqQixLQUFLLENBQUMsSUFBSSxFQUFFSSxTQUFTLENBQUM7TUFDbkMrSixZQUFZLEVBQUU7TUFDZCxJQUFJRixtQkFBbUIsRUFBRTtRQUN2QixJQUFNakIsT0FBTyxHQUFHb0IsS0FBSyxDQUFDdkIsVUFBVSxDQUFDLENBQUM7UUFDbEMsSUFBTXlCLGFBQWEsR0FBR3RCLE9BQU8sQ0FBQ3VCLElBQUksQ0FDaEMsVUFBQzVCLEtBQUs7VUFBQSxPQUFLc0IsbUJBQW1CLENBQUN0QixLQUFLLENBQUMxRSxLQUFLLEVBQUVBLEtBQUssQ0FBQztRQUFBLENBQ3BELENBQUM7UUFDRCxJQUFJcUcsYUFBYSxFQUFFO1VBQ2pCckcsS0FBSyxHQUFHcUcsYUFBYSxDQUFDckcsS0FBSztVQUMzQmtHLFlBQVksS0FBSyxDQUFDLElBQUlBLFlBQVksRUFBRTtRQUN0QztNQUNGO01BQ0FDLEtBQUssQ0FBQ3hCLEdBQUcsQ0FBQ3hJLFNBQVMsRUFBRTZELEtBQUssQ0FBQztJQUM3QjtJQUNBLE9BQU9BLEtBQUs7RUFDZDtFQUNBb0csUUFBUSxDQUFDRyxVQUFVLEdBQUcsWUFBTTtJQUMxQkosS0FBSyxDQUFDMUYsS0FBSyxDQUFDLENBQUM7SUFDYjJGLFFBQVEsQ0FBQ0ksaUJBQWlCLENBQUMsQ0FBQztFQUM5QixDQUFDO0VBQ0RKLFFBQVEsQ0FBQ0YsWUFBWSxHQUFHO0lBQUEsT0FBTUEsWUFBWTtFQUFBO0VBQzFDRSxRQUFRLENBQUNJLGlCQUFpQixHQUFHLFlBQU07SUFDakNOLFlBQVksR0FBRyxDQUFDO0VBQ2xCLENBQUM7RUFDRCxPQUFPRSxRQUFRO0FBQ2pCOztBQUVBO0FBQ0EsU0FBU0ssZ0JBQWdCQSxDQUFDekosSUFBSSxFQUFFO0VBQzlCLElBQU02RSxJQUFJLEdBQUdrQixVQUFVLENBQ3JCLEVBQ0YsQ0FBQztFQUNELElBQUkyRCxRQUFRLEdBQUcsSUFBSTtFQUNuQixJQUFNQyxZQUFZLEdBQUdyQix3QkFBd0IsQ0FBQ0Qsc0JBQXNCLENBQUM7RUFDckUsSUFBTWMsS0FBSyxHQUFHNUUsV0FBVyxDQUFDLFlBQU07SUFDOUIsSUFBTXlCLEdBQUcsR0FBR2hHLElBQUksQ0FBQ2pCLEtBQUssQ0FBQyxJQUFJLEVBQUU4RixJQUFJLENBQUNRLEtBQUssQ0FBQztJQUN4QyxPQUFPVyxHQUFHO0VBQ1osQ0FBQyxDQUFDO0VBQ0YsU0FBU29ELFFBQVFBLENBQUEsRUFBRztJQUNsQixJQUFJLENBQUNPLFlBQVksQ0FBQ0QsUUFBUSxFQUFFdkssU0FBUyxDQUFDLEVBQUU7TUFDdEM2SCxVQUFVLENBQUNuQyxJQUFJLEVBQUUxRixTQUFTLENBQUM7TUFDM0J1SyxRQUFRLEdBQUd2SyxTQUFTO0lBQ3RCO0lBQ0EsT0FBT2dLLEtBQUssQ0FBQ25HLEtBQUs7RUFDcEI7RUFDQW9HLFFBQVEsQ0FBQ0csVUFBVSxHQUFHLFlBQU07SUFDMUIsT0FBT0osS0FBSyxDQUFDMUYsS0FBSyxDQUFDLENBQUM7RUFDdEIsQ0FBQztFQUNELE9BQU8yRixRQUFRO0FBQ2pCOztBQUVBO0FBQ0EsSUFBSVEsU0FBUztFQUNYLFNBQUFBLFVBQVk1RyxLQUFLLEVBQUU7SUFBQVosZUFBQSxPQUFBd0gsU0FBQTtJQUNqQixJQUFJLENBQUM1RyxLQUFLLEdBQUdBLEtBQUs7RUFDcEI7RUFBQyxPQUFBUCxZQUFBLENBQUFtSCxTQUFBO0lBQUFsSCxHQUFBO0lBQUFNLEtBQUEsRUFDRCxTQUFBNkcsS0FBS0EsQ0FBQSxFQUFHO01BQ04sT0FBTyxJQUFJLENBQUM3RyxLQUFLO0lBQ25CO0VBQUM7QUFBQSxHQUNGO0FBQ0QsSUFBSThHLEdBQUcsR0FBRyxPQUFPQyxPQUFPLEtBQUssV0FBVyxHQUFHQSxPQUFPLEdBQUdILFNBQVM7QUFDOUQsSUFBSUksWUFBWSxHQUFHLENBQUM7QUFDcEIsSUFBSUMsVUFBVSxHQUFHLENBQUM7QUFDbEIsU0FBU0MsZUFBZUEsQ0FBQSxFQUFHO0VBQ3pCLE9BQU87SUFDTEMsQ0FBQyxFQUFFSCxZQUFZO0lBQ2ZJLENBQUMsRUFBRSxLQUFLLENBQUM7SUFDVEMsQ0FBQyxFQUFFLElBQUk7SUFDUEMsQ0FBQyxFQUFFO0VBQ0wsQ0FBQztBQUNIO0FBQ0EsU0FBU0MsY0FBY0EsQ0FBQ3ZLLElBQUksRUFBZ0I7RUFBQSxJQUFkeEIsT0FBTyxHQUFBVyxTQUFBLENBQUF0QixNQUFBLFFBQUFzQixTQUFBLFFBQUFlLFNBQUEsR0FBQWYsU0FBQSxNQUFHLENBQUMsQ0FBQztFQUN4QyxJQUFJcUwsTUFBTSxHQUFHTixlQUFlLENBQUMsQ0FBQztFQUM5QixJQUFRbEIsbUJBQW1CLEdBQUt4SyxPQUFPLENBQS9Cd0ssbUJBQW1CO0VBQzNCLElBQUl5QixVQUFVO0VBQ2QsSUFBSXZCLFlBQVksR0FBRyxDQUFDO0VBQ3BCLFNBQVNFLFFBQVFBLENBQUEsRUFBRztJQUNsQixJQUFJc0IsU0FBUyxHQUFHRixNQUFNO0lBQ3RCLElBQVEzTSxNQUFNLEdBQUtzQixTQUFTLENBQXBCdEIsTUFBTTtJQUNkLEtBQUssSUFBSXlELENBQUMsR0FBRyxDQUFDLEVBQUVxSixDQUFDLEdBQUc5TSxNQUFNLEVBQUV5RCxDQUFDLEdBQUdxSixDQUFDLEVBQUVySixDQUFDLEVBQUUsRUFBRTtNQUN0QyxJQUFNc0osR0FBRyxHQUFHekwsU0FBUyxDQUFDbUMsQ0FBQyxDQUFDO01BQ3hCLElBQUksT0FBT3NKLEdBQUcsS0FBSyxVQUFVLElBQUl6SyxPQUFBLENBQU95SyxHQUFHLE1BQUssUUFBUSxJQUFJQSxHQUFHLEtBQUssSUFBSSxFQUFFO1FBQ3hFLElBQUlDLFdBQVcsR0FBR0gsU0FBUyxDQUFDTCxDQUFDO1FBQzdCLElBQUlRLFdBQVcsS0FBSyxJQUFJLEVBQUU7VUFDeEJILFNBQVMsQ0FBQ0wsQ0FBQyxHQUFHUSxXQUFXLEdBQUcsZUFBZ0IsSUFBSUMsT0FBTyxDQUFDLENBQUM7UUFDM0Q7UUFDQSxJQUFNQyxVQUFVLEdBQUdGLFdBQVcsQ0FBQ2xJLEdBQUcsQ0FBQ2lJLEdBQUcsQ0FBQztRQUN2QyxJQUFJRyxVQUFVLEtBQUssS0FBSyxDQUFDLEVBQUU7VUFDekJMLFNBQVMsR0FBR1IsZUFBZSxDQUFDLENBQUM7VUFDN0JXLFdBQVcsQ0FBQy9ILEdBQUcsQ0FBQzhILEdBQUcsRUFBRUYsU0FBUyxDQUFDO1FBQ2pDLENBQUMsTUFBTTtVQUNMQSxTQUFTLEdBQUdLLFVBQVU7UUFDeEI7TUFDRixDQUFDLE1BQU07UUFDTCxJQUFJQyxjQUFjLEdBQUdOLFNBQVMsQ0FBQ0osQ0FBQztRQUNoQyxJQUFJVSxjQUFjLEtBQUssSUFBSSxFQUFFO1VBQzNCTixTQUFTLENBQUNKLENBQUMsR0FBR1UsY0FBYyxHQUFHLGVBQWdCLElBQUlDLEdBQUcsQ0FBQyxDQUFDO1FBQzFEO1FBQ0EsSUFBTUMsYUFBYSxHQUFHRixjQUFjLENBQUNySSxHQUFHLENBQUNpSSxHQUFHLENBQUM7UUFDN0MsSUFBSU0sYUFBYSxLQUFLLEtBQUssQ0FBQyxFQUFFO1VBQzVCUixTQUFTLEdBQUdSLGVBQWUsQ0FBQyxDQUFDO1VBQzdCYyxjQUFjLENBQUNsSSxHQUFHLENBQUM4SCxHQUFHLEVBQUVGLFNBQVMsQ0FBQztRQUNwQyxDQUFDLE1BQU07VUFDTEEsU0FBUyxHQUFHUSxhQUFhO1FBQzNCO01BQ0Y7SUFDRjtJQUNBLElBQU1DLGNBQWMsR0FBR1QsU0FBUztJQUNoQyxJQUFJVSxNQUFNO0lBQ1YsSUFBSVYsU0FBUyxDQUFDUCxDQUFDLEtBQUtGLFVBQVUsRUFBRTtNQUM5Qm1CLE1BQU0sR0FBR1YsU0FBUyxDQUFDTixDQUFDO0lBQ3RCLENBQUMsTUFBTTtNQUNMZ0IsTUFBTSxHQUFHcEwsSUFBSSxDQUFDakIsS0FBSyxDQUFDLElBQUksRUFBRUksU0FBUyxDQUFDO01BQ3BDK0osWUFBWSxFQUFFO01BQ2QsSUFBSUYsbUJBQW1CLEVBQUU7UUFBQSxJQUFBcUMsaUJBQUEsRUFBQUMsV0FBQSxFQUFBQyxrQkFBQTtRQUN2QixJQUFNQyxlQUFlLElBQUFILGlCQUFBLElBQUFDLFdBQUEsR0FBR2IsVUFBVSxjQUFBYSxXQUFBLGdCQUFBQyxrQkFBQSxHQUFWRCxXQUFBLENBQVl6QixLQUFLLGNBQUEwQixrQkFBQSx1QkFBakJBLGtCQUFBLENBQUFFLElBQUEsQ0FBQUgsV0FBb0IsQ0FBQyxjQUFBRCxpQkFBQSxjQUFBQSxpQkFBQSxHQUFJWixVQUFVO1FBQzNELElBQUllLGVBQWUsSUFBSSxJQUFJLElBQUl4QyxtQkFBbUIsQ0FBQ3dDLGVBQWUsRUFBRUosTUFBTSxDQUFDLEVBQUU7VUFDM0VBLE1BQU0sR0FBR0ksZUFBZTtVQUN4QnRDLFlBQVksS0FBSyxDQUFDLElBQUlBLFlBQVksRUFBRTtRQUN0QztRQUNBLElBQU13QyxZQUFZLEdBQUd2TCxPQUFBLENBQU9pTCxNQUFNLE1BQUssUUFBUSxJQUFJQSxNQUFNLEtBQUssSUFBSSxJQUFJLE9BQU9BLE1BQU0sS0FBSyxVQUFVO1FBQ2xHWCxVQUFVLEdBQUdpQixZQUFZLEdBQUcsSUFBSTVCLEdBQUcsQ0FBQ3NCLE1BQU0sQ0FBQyxHQUFHQSxNQUFNO01BQ3REO0lBQ0Y7SUFDQUQsY0FBYyxDQUFDaEIsQ0FBQyxHQUFHRixVQUFVO0lBQzdCa0IsY0FBYyxDQUFDZixDQUFDLEdBQUdnQixNQUFNO0lBQ3pCLE9BQU9BLE1BQU07RUFDZjtFQUNBaEMsUUFBUSxDQUFDRyxVQUFVLEdBQUcsWUFBTTtJQUMxQmlCLE1BQU0sR0FBR04sZUFBZSxDQUFDLENBQUM7SUFDMUJkLFFBQVEsQ0FBQ0ksaUJBQWlCLENBQUMsQ0FBQztFQUM5QixDQUFDO0VBQ0RKLFFBQVEsQ0FBQ0YsWUFBWSxHQUFHO0lBQUEsT0FBTUEsWUFBWTtFQUFBO0VBQzFDRSxRQUFRLENBQUNJLGlCQUFpQixHQUFHLFlBQU07SUFDakNOLFlBQVksR0FBRyxDQUFDO0VBQ2xCLENBQUM7RUFDRCxPQUFPRSxRQUFRO0FBQ2pCOztBQUVBO0FBQ0EsU0FBU3VDLHFCQUFxQkEsQ0FBQ0MsZ0JBQWdCLEVBQTZCO0VBQUEsU0FBQUMsSUFBQSxHQUFBMU0sU0FBQSxDQUFBdEIsTUFBQSxFQUF4QmlPLHNCQUFzQixPQUFBOUssS0FBQSxDQUFBNkssSUFBQSxPQUFBQSxJQUFBLFdBQUFFLEtBQUEsTUFBQUEsS0FBQSxHQUFBRixJQUFBLEVBQUFFLEtBQUE7SUFBdEJELHNCQUFzQixDQUFBQyxLQUFBLFFBQUE1TSxTQUFBLENBQUE0TSxLQUFBO0VBQUE7RUFDeEUsSUFBTUMsNEJBQTRCLEdBQUcsT0FBT0osZ0JBQWdCLEtBQUssVUFBVSxHQUFHO0lBQzVFbE4sT0FBTyxFQUFFa04sZ0JBQWdCO0lBQ3pCak4sY0FBYyxFQUFFbU47RUFDbEIsQ0FBQyxHQUFHRixnQkFBZ0I7RUFDcEIsSUFBTUssZUFBZSxHQUFHLFNBQWxCQSxlQUFlQSxDQUFBLEVBQThCO0lBQUEsU0FBQUMsS0FBQSxHQUFBL00sU0FBQSxDQUFBdEIsTUFBQSxFQUF2QnNELGtCQUFrQixPQUFBSCxLQUFBLENBQUFrTCxLQUFBLEdBQUFDLEtBQUEsTUFBQUEsS0FBQSxHQUFBRCxLQUFBLEVBQUFDLEtBQUE7TUFBbEJoTCxrQkFBa0IsQ0FBQWdMLEtBQUEsSUFBQWhOLFNBQUEsQ0FBQWdOLEtBQUE7SUFBQTtJQUM1QyxJQUFJQyxlQUFjLEdBQUcsQ0FBQztJQUN0QixJQUFJQyx5QkFBd0IsR0FBRyxDQUFDO0lBQ2hDLElBQUk1QixZQUFVO0lBQ2QsSUFBSTZCLHFCQUFxQixHQUFHLENBQUMsQ0FBQztJQUM5QixJQUFJNU8sVUFBVSxHQUFHeUQsa0JBQWtCLENBQUNpSCxHQUFHLENBQUMsQ0FBQztJQUN6QyxJQUFJakksT0FBQSxDQUFPekMsVUFBVSxNQUFLLFFBQVEsRUFBRTtNQUNsQzRPLHFCQUFxQixHQUFHNU8sVUFBVTtNQUNsQ0EsVUFBVSxHQUFHeUQsa0JBQWtCLENBQUNpSCxHQUFHLENBQUMsQ0FBQztJQUN2QztJQUNBckksZ0JBQWdCLENBQ2RyQyxVQUFVLGdGQUFBc0IsTUFBQSxDQUFBbUIsT0FBQSxDQUMyRXpDLFVBQVUsT0FDakcsQ0FBQztJQUNELElBQU02TyxlQUFlLEdBQUE1SyxhQUFBLENBQUFBLGFBQUEsS0FDaEJxSyw0QkFBNEIsR0FDNUJNLHFCQUFxQixDQUN6QjtJQUNELElBQ0U1TixPQUFPLEdBS0w2TixlQUFlLENBTGpCN04sT0FBTztNQUFBOE4scUJBQUEsR0FLTEQsZUFBZSxDQUpqQjVOLGNBQWM7TUFBZEEsY0FBYyxHQUFBNk4scUJBQUEsY0FBRyxFQUFFLEdBQUFBLHFCQUFBO01BQUFDLHFCQUFBLEdBSWpCRixlQUFlLENBSGpCRyxXQUFXO01BQVhBLFdBQVcsR0FBQUQscUJBQUEsY0FBR2xDLGNBQWMsR0FBQWtDLHFCQUFBO01BQUFFLHNCQUFBLEdBRzFCSixlQUFlLENBRmpCSyxrQkFBa0I7TUFBbEJBLGtCQUFrQixHQUFBRCxzQkFBQSxjQUFHLEVBQUUsR0FBQUEsc0JBQUE7TUFBQUUscUJBQUEsR0FFckJOLGVBQWUsQ0FEakI3TSxhQUFhO01BQWJBLGFBQWEsR0FBQW1OLHFCQUFBLGNBQUcsQ0FBQyxDQUFDLEdBQUFBLHFCQUFBO0lBRXBCLElBQU1DLG1CQUFtQixHQUFHL0wsYUFBYSxDQUFDcEMsY0FBYyxDQUFDO0lBQ3pELElBQU1vTyx1QkFBdUIsR0FBR2hNLGFBQWEsQ0FBQzZMLGtCQUFrQixDQUFDO0lBQ2pFLElBQU14TCxZQUFZLEdBQUdGLGVBQWUsQ0FBQ0Msa0JBQWtCLENBQUM7SUFDeEQsSUFBTTZMLGtCQUFrQixHQUFHdE8sT0FBTyxDQUFBSyxLQUFBLFVBQUMsU0FBU2tPLG9CQUFvQkEsQ0FBQSxFQUFHO01BQ2pFYixlQUFjLEVBQUU7TUFDaEIsT0FBTzFPLFVBQVUsQ0FBQ3FCLEtBQUssQ0FDckIsSUFBSSxFQUNKSSxTQUNGLENBQUM7SUFDSCxDQUFDLEVBQUFILE1BQUEsQ0FBQUMsa0JBQUEsQ0FBSzZOLG1CQUFtQixHQUFDO0lBQzFCLElBQUlyTCxRQUFRLEdBQUcsSUFBSTtJQUNuQixJQUFNeUwsUUFBUSxHQUFHUixXQUFXLENBQUEzTixLQUFBLFVBQUMsU0FBU29PLG1CQUFtQkEsQ0FBQSxFQUFHO01BQzFEZCx5QkFBd0IsRUFBRTtNQUMxQixJQUFNek4sb0JBQW9CLEdBQUd5QywyQkFBMkIsQ0FDdERELFlBQVksRUFDWmpDLFNBQ0YsQ0FBQztNQUNEc0wsWUFBVSxHQUFHdUMsa0JBQWtCLENBQUNqTyxLQUFLLENBQUMsSUFBSSxFQUFFSCxvQkFBb0IsQ0FBQztNQUNqRSxJQUFJLE1BQXVDO1FBQ3pDLElBQUF3TyxxQkFBQSxHQUF1RDVMLDZCQUE2QixDQUFDQyxRQUFRLEVBQUUvQixhQUFhLENBQUM7VUFBckdGLHFCQUFxQixHQUFBNE4scUJBQUEsQ0FBckI1TixxQkFBcUI7VUFBRUQsbUJBQW1CLEdBQUE2TixxQkFBQSxDQUFuQjdOLG1CQUFtQjtRQUNsRCxJQUFJQyxxQkFBcUIsQ0FBQ29DLFNBQVMsRUFBRTtVQUNuQ3BDLHFCQUFxQixDQUFDcUMsR0FBRyxDQUN2Qm5FLFVBQVUsRUFDVmtCLG9CQUFvQixFQUNwQjZMLFlBQ0YsQ0FBQztRQUNIO1FBQ0EsSUFBSWxMLG1CQUFtQixDQUFDcUMsU0FBUyxFQUFFO1VBQ2pDLElBQU0vQyx3QkFBd0IsR0FBR3dDLDJCQUEyQixDQUMxREQsWUFBWSxFQUNaakMsU0FDRixDQUFDO1VBQ0RJLG1CQUFtQixDQUFDc0MsR0FBRyxDQUNyQjtZQUFFakQsb0JBQW9CLEVBQXBCQSxvQkFBb0I7WUFBRUMsd0JBQXdCLEVBQXhCQTtVQUF5QixDQUFDLEVBQ2xEO1lBQUVILE9BQU8sRUFBUEEsT0FBTztZQUFFQyxjQUFjLEVBQUVtTztVQUFvQixDQUFDLEVBQ2hEM04sU0FDRixDQUFDO1FBQ0g7UUFDQSxJQUFJc0MsUUFBUSxFQUNWQSxRQUFRLEdBQUcsS0FBSztNQUNwQjtNQUNBLE9BQU9nSixZQUFVO0lBQ25CLENBQUMsRUFBQXpMLE1BQUEsQ0FBQUMsa0JBQUEsQ0FBSzhOLHVCQUF1QixHQUFDO0lBQzlCLE9BQU9wTixNQUFNLENBQUNDLE1BQU0sQ0FBQ3NOLFFBQVEsRUFBRTtNQUM3QnhQLFVBQVUsRUFBVkEsVUFBVTtNQUNWc1Asa0JBQWtCLEVBQWxCQSxrQkFBa0I7TUFDbEI1TCxZQUFZLEVBQVpBLFlBQVk7TUFDWmlMLHdCQUF3QixFQUFFLFNBQTFCQSx3QkFBd0JBLENBQUE7UUFBQSxPQUFRQSx5QkFBd0I7TUFBQTtNQUN4RGdCLDZCQUE2QixFQUFFLFNBQS9CQSw2QkFBNkJBLENBQUEsRUFBUTtRQUNuQ2hCLHlCQUF3QixHQUFHLENBQUM7TUFDOUIsQ0FBQztNQUNENUIsVUFBVSxFQUFFLFNBQVpBLFVBQVVBLENBQUE7UUFBQSxPQUFRQSxZQUFVO01BQUE7TUFDNUIyQixjQUFjLEVBQUUsU0FBaEJBLGNBQWNBLENBQUE7UUFBQSxPQUFRQSxlQUFjO01BQUE7TUFDcENrQixtQkFBbUIsRUFBRSxTQUFyQkEsbUJBQW1CQSxDQUFBLEVBQVE7UUFDekJsQixlQUFjLEdBQUcsQ0FBQztNQUNwQixDQUFDO01BQ0QxTixPQUFPLEVBQVBBLE9BQU87TUFDUGdPLFdBQVcsRUFBWEE7SUFDRixDQUFDLENBQUM7RUFDSixDQUFDO0VBQ0QvTSxNQUFNLENBQUNDLE1BQU0sQ0FBQ3FNLGVBQWUsRUFBRTtJQUM3QnNCLFNBQVMsRUFBRSxTQUFYQSxTQUFTQSxDQUFBO01BQUEsT0FBUXRCLGVBQWU7SUFBQTtFQUNsQyxDQUFDLENBQUM7RUFDRixPQUFPQSxlQUFlO0FBQ3hCO0FBQ0EsSUFBSXVCLGNBQWMsR0FBRyxlQUFnQjdCLHFCQUFxQixDQUFDcEIsY0FBYyxDQUFDOztBQUUxRTtBQUNBLElBQUlrRCx3QkFBd0IsR0FBRzlOLE1BQU0sQ0FBQ0MsTUFBTSxDQUMxQyxVQUFDOE4sb0JBQW9CLEVBQXVDO0VBQUEsSUFBckNDLGVBQWUsR0FBQXhPLFNBQUEsQ0FBQXRCLE1BQUEsUUFBQXNCLFNBQUEsUUFBQWUsU0FBQSxHQUFBZixTQUFBLE1BQUdxTyxjQUFjO0VBQ3JEbk4sY0FBYyxDQUNacU4sb0JBQW9CLDJIQUFBMU8sTUFBQSxDQUFBbUIsT0FBQSxDQUM0R3VOLG9CQUFvQixFQUN0SixDQUFDO0VBQ0QsSUFBTUUsaUJBQWlCLEdBQUdqTyxNQUFNLENBQUNrTyxJQUFJLENBQUNILG9CQUFvQixDQUFDO0VBQzNELElBQU10TSxZQUFZLEdBQUd3TSxpQkFBaUIsQ0FBQ2hOLEdBQUcsQ0FDeEMsVUFBQzhCLEdBQUc7SUFBQSxPQUFLZ0wsb0JBQW9CLENBQUNoTCxHQUFHLENBQUM7RUFBQSxDQUNwQyxDQUFDO0VBQ0QsSUFBTW9MLGtCQUFrQixHQUFHSCxlQUFlLENBQ3hDdk0sWUFBWSxFQUNaLFlBQTZCO0lBQUEsU0FBQTJNLEtBQUEsR0FBQTVPLFNBQUEsQ0FBQXRCLE1BQUEsRUFBekJlLG9CQUFvQixPQUFBb0MsS0FBQSxDQUFBK00sS0FBQSxHQUFBQyxLQUFBLE1BQUFBLEtBQUEsR0FBQUQsS0FBQSxFQUFBQyxLQUFBO01BQXBCcFAsb0JBQW9CLENBQUFvUCxLQUFBLElBQUE3TyxTQUFBLENBQUE2TyxLQUFBO0lBQUE7SUFDdEIsT0FBT3BQLG9CQUFvQixDQUFDcVAsTUFBTSxDQUFDLFVBQUNDLFdBQVcsRUFBRWxMLEtBQUssRUFBRW1MLEtBQUssRUFBSztNQUNoRUQsV0FBVyxDQUFDTixpQkFBaUIsQ0FBQ08sS0FBSyxDQUFDLENBQUMsR0FBR25MLEtBQUs7TUFDN0MsT0FBT2tMLFdBQVc7SUFDcEIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQ1IsQ0FDRixDQUFDO0VBQ0QsT0FBT0osa0JBQWtCO0FBQzNCLENBQUMsRUFDRDtFQUFFUCxTQUFTLEVBQUUsU0FBWEEsU0FBU0EsQ0FBQTtJQUFBLE9BQVFFLHdCQUF3QjtFQUFBO0FBQUMsQ0FDOUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LXRlc3Qtc2V0dXAvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZGlzdC9yZXNlbGVjdC5tanM/NDA4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZGV2TW9kZUNoZWNrcy9pZGVudGl0eUZ1bmN0aW9uQ2hlY2sudHNcbnZhciBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSAocmVzdWx0RnVuYywgaW5wdXRTZWxlY3RvcnNSZXN1bHRzLCBvdXRwdXRTZWxlY3RvclJlc3VsdCkgPT4ge1xuICBpZiAoaW5wdXRTZWxlY3RvcnNSZXN1bHRzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dFNlbGVjdG9yc1Jlc3VsdHNbMF0gPT09IG91dHB1dFNlbGVjdG9yUmVzdWx0KSB7XG4gICAgbGV0IGlzSW5wdXRTYW1lQXNPdXRwdXQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW1wdHlPYmplY3QgPSB7fTtcbiAgICAgIGlmIChyZXN1bHRGdW5jKGVtcHR5T2JqZWN0KSA9PT0gZW1wdHlPYmplY3QpXG4gICAgICAgIGlzSW5wdXRTYW1lQXNPdXRwdXQgPSB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBpZiAoaXNJbnB1dFNhbWVBc091dHB1dCkge1xuICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIDtcbiAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlRoZSByZXN1bHQgZnVuY3Rpb24gcmV0dXJuZWQgaXRzIG93biBpbnB1dHMgd2l0aG91dCBtb2RpZmljYXRpb24uIGUuZ1xcbmBjcmVhdGVTZWxlY3Rvcihbc3RhdGUgPT4gc3RhdGUudG9kb3NdLCB0b2RvcyA9PiB0b2RvcylgXFxuVGhpcyBjb3VsZCBsZWFkIHRvIGluZWZmaWNpZW50IG1lbW9pemF0aW9uIGFuZCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzLlxcbkVuc3VyZSB0cmFuc2Zvcm1hdGlvbiBsb2dpYyBpcyBpbiB0aGUgcmVzdWx0IGZ1bmN0aW9uLCBhbmQgZXh0cmFjdGlvbiBsb2dpYyBpcyBpbiB0aGUgaW5wdXQgc2VsZWN0b3JzLlwiLFxuICAgICAgICB7IHN0YWNrIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZGV2TW9kZUNoZWNrcy9pbnB1dFN0YWJpbGl0eUNoZWNrLnRzXG52YXIgcnVuSW5wdXRTdGFiaWxpdHlDaGVjayA9IChpbnB1dFNlbGVjdG9yUmVzdWx0c09iamVjdCwgb3B0aW9ucywgaW5wdXRTZWxlY3RvckFyZ3MpID0+IHtcbiAgY29uc3QgeyBtZW1vaXplLCBtZW1vaXplT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBpbnB1dFNlbGVjdG9yUmVzdWx0cywgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5IH0gPSBpbnB1dFNlbGVjdG9yUmVzdWx0c09iamVjdDtcbiAgY29uc3QgY3JlYXRlQW5FbXB0eU9iamVjdCA9IG1lbW9pemUoKCkgPT4gKHt9KSwgLi4ubWVtb2l6ZU9wdGlvbnMpO1xuICBjb25zdCBhcmVJbnB1dFNlbGVjdG9yUmVzdWx0c0VxdWFsID0gY3JlYXRlQW5FbXB0eU9iamVjdC5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0cykgPT09IGNyZWF0ZUFuRW1wdHlPYmplY3QuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5KTtcbiAgaWYgKCFhcmVJbnB1dFNlbGVjdG9yUmVzdWx0c0VxdWFsKSB7XG4gICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICA7XG4gICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiQW4gaW5wdXQgc2VsZWN0b3IgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gcGFzc2VkIHNhbWUgYXJndW1lbnRzLlxcblRoaXMgbWVhbnMgeW91ciBvdXRwdXQgc2VsZWN0b3Igd2lsbCBsaWtlbHkgcnVuIG1vcmUgZnJlcXVlbnRseSB0aGFuIGludGVuZGVkLlxcbkF2b2lkIHJldHVybmluZyBhIG5ldyByZWZlcmVuY2UgaW5zaWRlIHlvdXIgaW5wdXQgc2VsZWN0b3IsIGUuZy5cXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zLm1hcCh0b2RvID0+IHRvZG8uaWQpXSwgdG9kb0lkcyA9PiB0b2RvSWRzLmxlbmd0aClgXCIsXG4gICAgICB7XG4gICAgICAgIGFyZ3VtZW50czogaW5wdXRTZWxlY3RvckFyZ3MsXG4gICAgICAgIGZpcnN0SW5wdXRzOiBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcbiAgICAgICAgc2Vjb25kSW5wdXRzOiBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHksXG4gICAgICAgIHN0YWNrXG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2Rldk1vZGVDaGVja3Mvc2V0R2xvYmFsRGV2TW9kZUNoZWNrcy50c1xudmFyIGdsb2JhbERldk1vZGVDaGVja3MgPSB7XG4gIGlucHV0U3RhYmlsaXR5Q2hlY2s6IFwib25jZVwiLFxuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IFwib25jZVwiXG59O1xudmFyIHNldEdsb2JhbERldk1vZGVDaGVja3MgPSAoZGV2TW9kZUNoZWNrcykgPT4ge1xuICBPYmplY3QuYXNzaWduKGdsb2JhbERldk1vZGVDaGVja3MsIGRldk1vZGVDaGVja3MpO1xufTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgTk9UX0ZPVU5EID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcIk5PVF9GT1VORFwiKTtcbmZ1bmN0aW9uIGFzc2VydElzRnVuY3Rpb24oZnVuYywgZXJyb3JNZXNzYWdlID0gYGV4cGVjdGVkIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJHt0eXBlb2YgZnVuY31gKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRJc09iamVjdChvYmplY3QsIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbiBvYmplY3QsIGluc3RlYWQgcmVjZWl2ZWQgJHt0eXBlb2Ygb2JqZWN0fWApIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzQXJyYXlPZkZ1bmN0aW9ucyhhcnJheSwgZXJyb3JNZXNzYWdlID0gYGV4cGVjdGVkIGFsbCBpdGVtcyB0byBiZSBmdW5jdGlvbnMsIGluc3RlYWQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogYCkge1xuICBpZiAoIWFycmF5LmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIGNvbnN0IGl0ZW1UeXBlcyA9IGFycmF5Lm1hcChcbiAgICAgIChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiID8gYGZ1bmN0aW9uICR7aXRlbS5uYW1lIHx8IFwidW5uYW1lZFwifSgpYCA6IHR5cGVvZiBpdGVtXG4gICAgKS5qb2luKFwiLCBcIik7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtlcnJvck1lc3NhZ2V9WyR7aXRlbVR5cGVzfV1gKTtcbiAgfVxufVxudmFyIGVuc3VyZUlzQXJyYXkgPSAoaXRlbSkgPT4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV07XG59O1xuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGNyZWF0ZVNlbGVjdG9yQXJncykge1xuICBjb25zdCBkZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KGNyZWF0ZVNlbGVjdG9yQXJnc1swXSkgPyBjcmVhdGVTZWxlY3RvckFyZ3NbMF0gOiBjcmVhdGVTZWxlY3RvckFyZ3M7XG4gIGFzc2VydElzQXJyYXlPZkZ1bmN0aW9ucyhcbiAgICBkZXBlbmRlbmNpZXMsXG4gICAgYGNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYWxsIGlucHV0LXNlbGVjdG9ycyB0byBiZSBmdW5jdGlvbnMsIGJ1dCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBgXG4gICk7XG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5mdW5jdGlvbiBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoZGVwZW5kZW5jaWVzLCBpbnB1dFNlbGVjdG9yQXJncykge1xuICBjb25zdCBpbnB1dFNlbGVjdG9yUmVzdWx0cyA9IFtdO1xuICBjb25zdCB7IGxlbmd0aCB9ID0gZGVwZW5kZW5jaWVzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaW5wdXRTZWxlY3RvclJlc3VsdHMucHVzaChkZXBlbmRlbmNpZXNbaV0uYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvckFyZ3MpKTtcbiAgfVxuICByZXR1cm4gaW5wdXRTZWxlY3RvclJlc3VsdHM7XG59XG52YXIgZ2V0RGV2TW9kZUNoZWNrc0V4ZWN1dGlvbkluZm8gPSAoZmlyc3RSdW4sIGRldk1vZGVDaGVja3MpID0+IHtcbiAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIGlucHV0U3RhYmlsaXR5Q2hlY2sgfSA9IHtcbiAgICAuLi5nbG9iYWxEZXZNb2RlQ2hlY2tzLFxuICAgIC4uLmRldk1vZGVDaGVja3NcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjogaWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4sXG4gICAgICBydW46IHJ1bklkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH0sXG4gICAgaW5wdXRTdGFiaWxpdHlDaGVjazoge1xuICAgICAgc2hvdWxkUnVuOiBpbnB1dFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGlucHV0U3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLFxuICAgICAgcnVuOiBydW5JbnB1dFN0YWJpbGl0eUNoZWNrXG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2F1dG90cmFja01lbW9pemUvYXV0b3RyYWNraW5nLnRzXG52YXIgJFJFVklTSU9OID0gMDtcbnZhciBDVVJSRU5UX1RSQUNLRVIgPSBudWxsO1xudmFyIENlbGwgPSBjbGFzcyB7XG4gIHJldmlzaW9uID0gJFJFVklTSU9OO1xuICBfdmFsdWU7XG4gIF9sYXN0VmFsdWU7XG4gIF9pc0VxdWFsID0gdHJpcGxlRXE7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCA9IHRyaXBsZUVxKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9sYXN0VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgdGhpcy5faXNFcXVhbCA9IGlzRXF1YWw7XG4gIH1cbiAgLy8gV2hlbmV2ZXIgYSBzdG9yYWdlIHZhbHVlIGlzIHJlYWQsIGl0J2xsIGFkZCBpdHNlbGYgdG8gdGhlIGN1cnJlbnQgdHJhY2tlciBpZlxuICAvLyBvbmUgZXhpc3RzLCBlbnRhbmdsaW5nIGl0cyBzdGF0ZSB3aXRoIHRoYXQgY2FjaGUuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICBDVVJSRU5UX1RSQUNLRVI/LmFkZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgLy8gV2hlbmV2ZXIgYSBzdG9yYWdlIHZhbHVlIGlzIHVwZGF0ZWQsIHdlIGJ1bXAgdGhlIGdsb2JhbCByZXZpc2lvbiBjbG9jayxcbiAgLy8gYXNzaWduIHRoZSByZXZpc2lvbiBmb3IgdGhpcyBzdG9yYWdlIHRvIHRoZSBuZXcgdmFsdWUsIF9hbmRfIHdlIHNjaGVkdWxlIGFcbiAgLy8gcmVyZW5kZXIuIFRoaXMgaXMgaW1wb3J0YW50LCBhbmQgaXQncyB3aGF0IG1ha2VzIGF1dG90cmFja2luZyAgX3B1bGxfXG4gIC8vIGJhc2VkLiBXZSBkb24ndCBhY3RpdmVseSB0ZWxsIHRoZSBjYWNoZXMgd2hpY2ggZGVwZW5kIG9uIHRoZSBzdG9yYWdlIHRoYXRcbiAgLy8gYW55dGhpbmcgaGFzIGhhcHBlbmVkLiBJbnN0ZWFkLCB3ZSByZWNvbXB1dGUgdGhlIGNhY2hlcyB3aGVuIG5lZWRlZC5cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IG5ld1ZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgdGhpcy5yZXZpc2lvbiA9ICsrJFJFVklTSU9OO1xuICB9XG59O1xuZnVuY3Rpb24gdHJpcGxlRXEoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbnZhciBUcmFja2luZ0NhY2hlID0gY2xhc3Mge1xuICBfY2FjaGVkVmFsdWU7XG4gIF9jYWNoZWRSZXZpc2lvbiA9IC0xO1xuICBfZGVwcyA9IFtdO1xuICBoaXRzID0gMDtcbiAgZm47XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NhY2hlZFZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMuX2NhY2hlZFJldmlzaW9uID0gLTE7XG4gICAgdGhpcy5fZGVwcyA9IFtdO1xuICAgIHRoaXMuaGl0cyA9IDA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGlmICh0aGlzLnJldmlzaW9uID4gdGhpcy5fY2FjaGVkUmV2aXNpb24pIHtcbiAgICAgIGNvbnN0IHsgZm4gfSA9IHRoaXM7XG4gICAgICBjb25zdCBjdXJyZW50VHJhY2tlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBwcmV2VHJhY2tlciA9IENVUlJFTlRfVFJBQ0tFUjtcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IGN1cnJlbnRUcmFja2VyO1xuICAgICAgdGhpcy5fY2FjaGVkVmFsdWUgPSBmbigpO1xuICAgICAgQ1VSUkVOVF9UUkFDS0VSID0gcHJldlRyYWNrZXI7XG4gICAgICB0aGlzLmhpdHMrKztcbiAgICAgIHRoaXMuX2RlcHMgPSBBcnJheS5mcm9tKGN1cnJlbnRUcmFja2VyKTtcbiAgICAgIHRoaXMuX2NhY2hlZFJldmlzaW9uID0gdGhpcy5yZXZpc2lvbjtcbiAgICB9XG4gICAgQ1VSUkVOVF9UUkFDS0VSPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFZhbHVlO1xuICB9XG4gIGdldCByZXZpc2lvbigpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4udGhpcy5fZGVwcy5tYXAoKGQpID0+IGQucmV2aXNpb24pLCAwKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFZhbHVlKGNlbGwpIHtcbiAgaWYgKCEoY2VsbCBpbnN0YW5jZW9mIENlbGwpKSB7XG4gICAgY29uc29sZS53YXJuKFwiTm90IGEgdmFsaWQgY2VsbCEgXCIsIGNlbGwpO1xuICB9XG4gIHJldHVybiBjZWxsLnZhbHVlO1xufVxuZnVuY3Rpb24gc2V0VmFsdWUoc3RvcmFnZSwgdmFsdWUpIHtcbiAgaWYgKCEoc3RvcmFnZSBpbnN0YW5jZW9mIENlbGwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwic2V0VmFsdWUgbXVzdCBiZSBwYXNzZWQgYSB0cmFja2VkIHN0b3JlIGNyZWF0ZWQgd2l0aCBgY3JlYXRlU3RvcmFnZWAuXCJcbiAgICApO1xuICB9XG4gIHN0b3JhZ2UudmFsdWUgPSBzdG9yYWdlLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNlbGwoaW5pdGlhbFZhbHVlLCBpc0VxdWFsID0gdHJpcGxlRXEpIHtcbiAgcmV0dXJuIG5ldyBDZWxsKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZShmbikge1xuICBhc3NlcnRJc0Z1bmN0aW9uKFxuICAgIGZuLFxuICAgIFwidGhlIGZpcnN0IHBhcmFtZXRlciB0byBgY3JlYXRlQ2FjaGVgIG11c3QgYmUgYSBmdW5jdGlvblwiXG4gICk7XG4gIHJldHVybiBuZXcgVHJhY2tpbmdDYWNoZShmbik7XG59XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL3RyYWNraW5nLnRzXG52YXIgbmV2ZXJFcSA9IChhLCBiKSA9PiBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVRhZygpIHtcbiAgcmV0dXJuIGNyZWF0ZUNlbGwobnVsbCwgbmV2ZXJFcSk7XG59XG5mdW5jdGlvbiBkaXJ0eVRhZyh0YWcsIHZhbHVlKSB7XG4gIHNldFZhbHVlKHRhZywgdmFsdWUpO1xufVxudmFyIGNvbnN1bWVDb2xsZWN0aW9uID0gKG5vZGUpID0+IHtcbiAgbGV0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZztcbiAgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgIHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZyA9IGNyZWF0ZVRhZygpO1xuICB9XG4gIGdldFZhbHVlKHRhZyk7XG59O1xudmFyIGRpcnR5Q29sbGVjdGlvbiA9IChub2RlKSA9PiB7XG4gIGNvbnN0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZztcbiAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgIGRpcnR5VGFnKHRhZywgbnVsbCk7XG4gIH1cbn07XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL3Byb3h5LnRzXG52YXIgUkVEVVhfUFJPWFlfTEFCRUwgPSBTeW1ib2woKTtcbnZhciBuZXh0SWQgPSAwO1xudmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbnZhciBPYmplY3RUcmVlTm9kZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudGFnLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgcHJveHkgPSBuZXcgUHJveHkodGhpcywgb2JqZWN0UHJveHlIYW5kbGVyKTtcbiAgdGFnID0gY3JlYXRlVGFnKCk7XG4gIHRhZ3MgPSB7fTtcbiAgY2hpbGRyZW4gPSB7fTtcbiAgY29sbGVjdGlvblRhZyA9IG51bGw7XG4gIGlkID0gbmV4dElkKys7XG59O1xudmFyIG9iamVjdFByb3h5SGFuZGxlciA9IHtcbiAgZ2V0KG5vZGUsIGtleSkge1xuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVJlc3VsdCgpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgICBjb25zdCBjaGlsZFZhbHVlID0gUmVmbGVjdC5nZXQodmFsdWUsIGtleSk7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgaW4gcHJvdG8pIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgY2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldO1xuICAgICAgICBpZiAoY2hpbGROb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlLmNoaWxkcmVuW2tleV0gPSBjcmVhdGVOb2RlKGNoaWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGUudGFnKSB7XG4gICAgICAgICAgZ2V0VmFsdWUoY2hpbGROb2RlLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5wcm94eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0YWcgPSBub2RlLnRhZ3Nba2V5XTtcbiAgICAgICAgaWYgKHRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGFnID0gbm9kZS50YWdzW2tleV0gPSBjcmVhdGVUYWcoKTtcbiAgICAgICAgICB0YWcudmFsdWUgPSBjaGlsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKHRhZyk7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBjYWxjdWxhdGVSZXN1bHQoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICBvd25LZXlzKG5vZGUpIHtcbiAgICBjb25zdW1lQ29sbGVjdGlvbihub2RlKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKG5vZGUudmFsdWUpO1xuICB9LFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZSwgcHJvcCkge1xuICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLnZhbHVlLCBwcm9wKTtcbiAgfSxcbiAgaGFzKG5vZGUsIHByb3ApIHtcbiAgICByZXR1cm4gUmVmbGVjdC5oYXMobm9kZS52YWx1ZSwgcHJvcCk7XG4gIH1cbn07XG52YXIgQXJyYXlUcmVlTm9kZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudGFnLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgcHJveHkgPSBuZXcgUHJveHkoW3RoaXNdLCBhcnJheVByb3h5SGFuZGxlcik7XG4gIHRhZyA9IGNyZWF0ZVRhZygpO1xuICB0YWdzID0ge307XG4gIGNoaWxkcmVuID0ge307XG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsO1xuICBpZCA9IG5leHRJZCsrO1xufTtcbnZhciBhcnJheVByb3h5SGFuZGxlciA9IHtcbiAgZ2V0KFtub2RlXSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgY29uc3VtZUNvbGxlY3Rpb24obm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0KG5vZGUsIGtleSk7XG4gIH0sXG4gIG93bktleXMoW25vZGVdKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5vd25LZXlzKG5vZGUpO1xuICB9LFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoW25vZGVdLCBwcm9wKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZSwgcHJvcCk7XG4gIH0sXG4gIGhhcyhbbm9kZV0sIHByb3ApIHtcbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmhhcyhub2RlLCBwcm9wKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheVRyZWVOb2RlKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IE9iamVjdFRyZWVOb2RlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUobm9kZSwgbmV3VmFsdWUpIHtcbiAgY29uc3QgeyB2YWx1ZSwgdGFncywgY2hpbGRyZW4gfSA9IG5vZGU7XG4gIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkobmV3VmFsdWUpICYmIHZhbHVlLmxlbmd0aCAhPT0gbmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGxldCBvbGRLZXlzU2l6ZSA9IDA7XG4gICAgICBsZXQgbmV3S2V5c1NpemUgPSAwO1xuICAgICAgbGV0IGFueUtleXNBZGRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBfa2V5IGluIHZhbHVlKSB7XG4gICAgICAgIG9sZEtleXNTaXplKys7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdWYWx1ZSkge1xuICAgICAgICBuZXdLZXlzU2l6ZSsrO1xuICAgICAgICBpZiAoIShrZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgYW55S2V5c0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaXNEaWZmZXJlbnQgPSBhbnlLZXlzQWRkZWQgfHwgb2xkS2V5c1NpemUgIT09IG5ld0tleXNTaXplO1xuICAgICAgaWYgKGlzRGlmZmVyZW50KSB7XG4gICAgICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gdGFncykge1xuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIGNvbnN0IG5ld0NoaWxkVmFsdWUgPSBuZXdWYWx1ZVtrZXldO1xuICAgIGlmIChjaGlsZFZhbHVlICE9PSBuZXdDaGlsZFZhbHVlKSB7XG4gICAgICBkaXJ0eUNvbGxlY3Rpb24obm9kZSk7XG4gICAgICBkaXJ0eVRhZyh0YWdzW2tleV0sIG5ld0NoaWxkVmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgbmV3Q2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRhZ3Nba2V5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRyZW4pIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlbltrZXldO1xuICAgIGNvbnN0IG5ld0NoaWxkVmFsdWUgPSBuZXdWYWx1ZVtrZXldO1xuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBjaGlsZE5vZGUudmFsdWU7XG4gICAgaWYgKGNoaWxkVmFsdWUgPT09IG5ld0NoaWxkVmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgbmV3Q2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlTm9kZShjaGlsZE5vZGUsIG5ld0NoaWxkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVOb2RlKGNoaWxkTm9kZSk7XG4gICAgICBkZWxldGUgY2hpbGRyZW5ba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlbGV0ZU5vZGUobm9kZSkge1xuICBpZiAobm9kZS50YWcpIHtcbiAgICBkaXJ0eVRhZyhub2RlLnRhZywgbnVsbCk7XG4gIH1cbiAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBub2RlLnRhZ3MpIHtcbiAgICBkaXJ0eVRhZyhub2RlLnRhZ3Nba2V5XSwgbnVsbCk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgIGRlbGV0ZU5vZGUobm9kZS5jaGlsZHJlbltrZXldKTtcbiAgfVxufVxuXG4vLyBzcmMvbHJ1TWVtb2l6ZS50c1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uQ2FjaGUoZXF1YWxzKSB7XG4gIGxldCBlbnRyeTtcbiAgcmV0dXJuIHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBpZiAoZW50cnkgJiYgZXF1YWxzKGVudHJ5LmtleSwga2V5KSkge1xuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgIGVudHJ5ID0geyBrZXksIHZhbHVlIH07XG4gICAgfSxcbiAgICBnZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJ5ID8gW2VudHJ5XSA6IFtdO1xuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBlbnRyeSA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcbiAgbGV0IGVudHJpZXMgPSBbXTtcbiAgZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGNvbnN0IGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleCgoZW50cnkpID0+IGVxdWFscyhrZXksIGVudHJ5LmtleSkpO1xuICAgIGlmIChjYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XTtcbiAgICAgIGlmIChjYWNoZUluZGV4ID4gMCkge1xuICAgICAgICBlbnRyaWVzLnNwbGljZShjYWNoZUluZGV4LCAxKTtcbiAgICAgICAgZW50cmllcy51bnNoaWZ0KGVudHJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuICBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChnZXQoa2V5KSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICBlbnRyaWVzLnVuc2hpZnQoeyBrZXksIHZhbHVlIH0pO1xuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBlbnRyaWVzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGVudHJpZXMgPSBbXTtcbiAgfVxuICByZXR1cm4geyBnZXQsIHB1dCwgZ2V0RW50cmllcywgY2xlYXIgfTtcbn1cbnZhciByZWZlcmVuY2VFcXVhbGl0eUNoZWNrID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjaykge1xuICByZXR1cm4gZnVuY3Rpb24gYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwocHJldiwgbmV4dCkge1xuICAgIGlmIChwcmV2ID09PSBudWxsIHx8IG5leHQgPT09IG51bGwgfHwgcHJldi5sZW5ndGggIT09IG5leHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBwcmV2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXF1YWxpdHlDaGVjayhwcmV2W2ldLCBuZXh0W2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gbHJ1TWVtb2l6ZShmdW5jLCBlcXVhbGl0eUNoZWNrT3JPcHRpb25zKSB7XG4gIGNvbnN0IHByb3ZpZGVkT3B0aW9ucyA9IHR5cGVvZiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zID09PSBcIm9iamVjdFwiID8gZXF1YWxpdHlDaGVja09yT3B0aW9ucyA6IHsgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9ucyB9O1xuICBjb25zdCB7XG4gICAgZXF1YWxpdHlDaGVjayA9IHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2ssXG4gICAgbWF4U2l6ZSA9IDEsXG4gICAgcmVzdWx0RXF1YWxpdHlDaGVja1xuICB9ID0gcHJvdmlkZWRPcHRpb25zO1xuICBjb25zdCBjb21wYXJhdG9yID0gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spO1xuICBsZXQgcmVzdWx0c0NvdW50ID0gMDtcbiAgY29uc3QgY2FjaGUgPSBtYXhTaXplIDw9IDEgPyBjcmVhdGVTaW5nbGV0b25DYWNoZShjb21wYXJhdG9yKSA6IGNyZWF0ZUxydUNhY2hlKG1heFNpemUsIGNvbXBhcmF0b3IpO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKTtcbiAgICBpZiAodmFsdWUgPT09IE5PVF9GT1VORCkge1xuICAgICAgdmFsdWUgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICByZXN1bHRzQ291bnQrKztcbiAgICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBjYWNoZS5nZXRFbnRyaWVzKCk7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRW50cnkgPSBlbnRyaWVzLmZpbmQoXG4gICAgICAgICAgKGVudHJ5KSA9PiByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlLCB2YWx1ZSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nRW50cnkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoaW5nRW50cnkudmFsdWU7XG4gICAgICAgICAgcmVzdWx0c0NvdW50ICE9PSAwICYmIHJlc3VsdHNDb3VudC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5wdXQoYXJndW1lbnRzLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gKCkgPT4ge1xuICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQoKTtcbiAgfTtcbiAgbWVtb2l6ZWQucmVzdWx0c0NvdW50ID0gKCkgPT4gcmVzdWx0c0NvdW50O1xuICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCA9ICgpID0+IHtcbiAgICByZXN1bHRzQ291bnQgPSAwO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL2F1dG90cmFja01lbW9pemUudHNcbmZ1bmN0aW9uIGF1dG90cmFja01lbW9pemUoZnVuYykge1xuICBjb25zdCBub2RlID0gY3JlYXRlTm9kZShcbiAgICBbXVxuICApO1xuICBsZXQgbGFzdEFyZ3MgPSBudWxsO1xuICBjb25zdCBzaGFsbG93RXF1YWwgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IocmVmZXJlbmNlRXF1YWxpdHlDaGVjayk7XG4gIGNvbnN0IGNhY2hlID0gY3JlYXRlQ2FjaGUoKCkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGZ1bmMuYXBwbHkobnVsbCwgbm9kZS5wcm94eSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG4gIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgIGlmICghc2hhbGxvd0VxdWFsKGxhc3RBcmdzLCBhcmd1bWVudHMpKSB7XG4gICAgICB1cGRhdGVOb2RlKG5vZGUsIGFyZ3VtZW50cyk7XG4gICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICB9XG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGNhY2hlLmNsZWFyKCk7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gc3JjL3dlYWtNYXBNZW1vaXplLnRzXG52YXIgU3Ryb25nUmVmID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBkZXJlZigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufTtcbnZhciBSZWYgPSB0eXBlb2YgV2Vha1JlZiAhPT0gXCJ1bmRlZmluZWRcIiA/IFdlYWtSZWYgOiBTdHJvbmdSZWY7XG52YXIgVU5URVJNSU5BVEVEID0gMDtcbnZhciBURVJNSU5BVEVEID0gMTtcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlTm9kZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBzOiBVTlRFUk1JTkFURUQsXG4gICAgdjogdm9pZCAwLFxuICAgIG86IG51bGwsXG4gICAgcDogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gd2Vha01hcE1lbW9pemUoZnVuYywgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBmbk5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgY29uc3QgeyByZXN1bHRFcXVhbGl0eUNoZWNrIH0gPSBvcHRpb25zO1xuICBsZXQgbGFzdFJlc3VsdDtcbiAgbGV0IHJlc3VsdHNDb3VudCA9IDA7XG4gIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgIGxldCBjYWNoZU5vZGUgPSBmbk5vZGU7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGFyZ3VtZW50cztcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiICYmIGFyZyAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgb2JqZWN0Q2FjaGUgPSBjYWNoZU5vZGUubztcbiAgICAgICAgaWYgKG9iamVjdENhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgY2FjaGVOb2RlLm8gPSBvYmplY3RDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iamVjdE5vZGUgPSBvYmplY3RDYWNoZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKG9iamVjdE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIG9iamVjdENhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gb2JqZWN0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHByaW1pdGl2ZUNhY2hlID0gY2FjaGVOb2RlLnA7XG4gICAgICAgIGlmIChwcmltaXRpdmVDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhY2hlTm9kZS5wID0gcHJpbWl0aXZlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZU5vZGUgPSBwcmltaXRpdmVDYWNoZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZU5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIHByaW1pdGl2ZUNhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gcHJpbWl0aXZlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkTm9kZSA9IGNhY2hlTm9kZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChjYWNoZU5vZGUucyA9PT0gVEVSTUlOQVRFRCkge1xuICAgICAgcmVzdWx0ID0gY2FjaGVOb2RlLnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIHJlc3VsdHNDb3VudCsrO1xuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgY29uc3QgbGFzdFJlc3VsdFZhbHVlID0gbGFzdFJlc3VsdD8uZGVyZWY/LigpID8/IGxhc3RSZXN1bHQ7XG4gICAgICAgIGlmIChsYXN0UmVzdWx0VmFsdWUgIT0gbnVsbCAmJiByZXN1bHRFcXVhbGl0eUNoZWNrKGxhc3RSZXN1bHRWYWx1ZSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGxhc3RSZXN1bHRWYWx1ZTtcbiAgICAgICAgICByZXN1bHRzQ291bnQgIT09IDAgJiYgcmVzdWx0c0NvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVlZHNXZWFrUmVmID0gdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiByZXN1bHQgIT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBsYXN0UmVzdWx0ID0gbmVlZHNXZWFrUmVmID8gbmV3IFJlZihyZXN1bHQpIDogcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICB0ZXJtaW5hdGVkTm9kZS5zID0gVEVSTUlOQVRFRDtcbiAgICB0ZXJtaW5hdGVkTm9kZS52ID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICBmbk5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCgpO1xuICB9O1xuICBtZW1vaXplZC5yZXN1bHRzQ291bnQgPSAoKSA9PiByZXN1bHRzQ291bnQ7XG4gIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50ID0gKCkgPT4ge1xuICAgIHJlc3VsdHNDb3VudCA9IDA7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gc3JjL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvci50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKG1lbW9pemVPck9wdGlvbnMsIC4uLm1lbW9pemVPcHRpb25zRnJvbUFyZ3MpIHtcbiAgY29uc3QgY3JlYXRlU2VsZWN0b3JDcmVhdG9yT3B0aW9ucyA9IHR5cGVvZiBtZW1vaXplT3JPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgbWVtb2l6ZTogbWVtb2l6ZU9yT3B0aW9ucyxcbiAgICBtZW1vaXplT3B0aW9uczogbWVtb2l6ZU9wdGlvbnNGcm9tQXJnc1xuICB9IDogbWVtb2l6ZU9yT3B0aW9ucztcbiAgY29uc3QgY3JlYXRlU2VsZWN0b3IyID0gKC4uLmNyZWF0ZVNlbGVjdG9yQXJncykgPT4ge1xuICAgIGxldCByZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgbGV0IGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgbGV0IGxhc3RSZXN1bHQ7XG4gICAgbGV0IGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHt9O1xuICAgIGxldCByZXN1bHRGdW5jID0gY3JlYXRlU2VsZWN0b3JBcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZGlyZWN0bHlQYXNzZWRPcHRpb25zID0gcmVzdWx0RnVuYztcbiAgICAgIHJlc3VsdEZ1bmMgPSBjcmVhdGVTZWxlY3RvckFyZ3MucG9wKCk7XG4gICAgfVxuICAgIGFzc2VydElzRnVuY3Rpb24oXG4gICAgICByZXN1bHRGdW5jLFxuICAgICAgYGNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYW4gb3V0cHV0IGZ1bmN0aW9uIGFmdGVyIHRoZSBpbnB1dHMsIGJ1dCByZWNlaXZlZDogWyR7dHlwZW9mIHJlc3VsdEZ1bmN9XWBcbiAgICApO1xuICAgIGNvbnN0IGNvbWJpbmVkT3B0aW9ucyA9IHtcbiAgICAgIC4uLmNyZWF0ZVNlbGVjdG9yQ3JlYXRvck9wdGlvbnMsXG4gICAgICAuLi5kaXJlY3RseVBhc3NlZE9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIG1lbW9pemUsXG4gICAgICBtZW1vaXplT3B0aW9ucyA9IFtdLFxuICAgICAgYXJnc01lbW9pemUgPSB3ZWFrTWFwTWVtb2l6ZSxcbiAgICAgIGFyZ3NNZW1vaXplT3B0aW9ucyA9IFtdLFxuICAgICAgZGV2TW9kZUNoZWNrcyA9IHt9XG4gICAgfSA9IGNvbWJpbmVkT3B0aW9ucztcbiAgICBjb25zdCBmaW5hbE1lbW9pemVPcHRpb25zID0gZW5zdXJlSXNBcnJheShtZW1vaXplT3B0aW9ucyk7XG4gICAgY29uc3QgZmluYWxBcmdzTWVtb2l6ZU9wdGlvbnMgPSBlbnN1cmVJc0FycmF5KGFyZ3NNZW1vaXplT3B0aW9ucyk7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gZ2V0RGVwZW5kZW5jaWVzKGNyZWF0ZVNlbGVjdG9yQXJncyk7XG4gICAgY29uc3QgbWVtb2l6ZWRSZXN1bHRGdW5jID0gbWVtb2l6ZShmdW5jdGlvbiByZWNvbXB1dGF0aW9uV3JhcHBlcigpIHtcbiAgICAgIHJlY29tcHV0YXRpb25zKys7XG4gICAgICByZXR1cm4gcmVzdWx0RnVuYy5hcHBseShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICApO1xuICAgIH0sIC4uLmZpbmFsTWVtb2l6ZU9wdGlvbnMpO1xuICAgIGxldCBmaXJzdFJ1biA9IHRydWU7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBhcmdzTWVtb2l6ZShmdW5jdGlvbiBkZXBlbmRlbmNpZXNDaGVja2VyKCkge1xuICAgICAgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zKys7XG4gICAgICBjb25zdCBpbnB1dFNlbGVjdG9yUmVzdWx0cyA9IGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyhcbiAgICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgICk7XG4gICAgICBsYXN0UmVzdWx0ID0gbWVtb2l6ZWRSZXN1bHRGdW5jLmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIGlucHV0U3RhYmlsaXR5Q2hlY2sgfSA9IGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvKGZpcnN0UnVuLCBkZXZNb2RlQ2hlY2tzKTtcbiAgICAgICAgaWYgKGlkZW50aXR5RnVuY3Rpb25DaGVjay5zaG91bGRSdW4pIHtcbiAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sucnVuKFxuICAgICAgICAgICAgcmVzdWx0RnVuYyxcbiAgICAgICAgICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLFxuICAgICAgICAgICAgbGFzdFJlc3VsdFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0U3RhYmlsaXR5Q2hlY2suc2hvdWxkUnVuKSB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5ID0gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKFxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dFN0YWJpbGl0eUNoZWNrLnJ1bihcbiAgICAgICAgICAgIHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9LFxuICAgICAgICAgICAgeyBtZW1vaXplLCBtZW1vaXplT3B0aW9uczogZmluYWxNZW1vaXplT3B0aW9ucyB9LFxuICAgICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RSdW4pXG4gICAgICAgICAgZmlyc3RSdW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH0sIC4uLmZpbmFsQXJnc01lbW9pemVPcHRpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzZWxlY3Rvciwge1xuICAgICAgcmVzdWx0RnVuYyxcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYyxcbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9uczogKCkgPT4gZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zLFxuICAgICAgcmVzZXREZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcbiAgICAgICAgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zID0gMDtcbiAgICAgIH0sXG4gICAgICBsYXN0UmVzdWx0OiAoKSA9PiBsYXN0UmVzdWx0LFxuICAgICAgcmVjb21wdXRhdGlvbnM6ICgpID0+IHJlY29tcHV0YXRpb25zLFxuICAgICAgcmVzZXRSZWNvbXB1dGF0aW9uczogKCkgPT4ge1xuICAgICAgICByZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgICB9LFxuICAgICAgbWVtb2l6ZSxcbiAgICAgIGFyZ3NNZW1vaXplXG4gICAgfSk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oY3JlYXRlU2VsZWN0b3IyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVTZWxlY3RvcjI7XG59XG52YXIgY3JlYXRlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKHdlYWtNYXBNZW1vaXplKTtcblxuLy8gc3JjL2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3Rvci50c1xudmFyIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciA9IE9iamVjdC5hc3NpZ24oXG4gIChpbnB1dFNlbGVjdG9yc09iamVjdCwgc2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3IpID0+IHtcbiAgICBhc3NlcnRJc09iamVjdChcbiAgICAgIGlucHV0U2VsZWN0b3JzT2JqZWN0LFxuICAgICAgYGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSAke3R5cGVvZiBpbnB1dFNlbGVjdG9yc09iamVjdH1gXG4gICAgKTtcbiAgICBjb25zdCBpbnB1dFNlbGVjdG9yS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U2VsZWN0b3JzT2JqZWN0KTtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBpbnB1dFNlbGVjdG9yS2V5cy5tYXAoXG4gICAgICAoa2V5KSA9PiBpbnB1dFNlbGVjdG9yc09iamVjdFtrZXldXG4gICAgKTtcbiAgICBjb25zdCBzdHJ1Y3R1cmVkU2VsZWN0b3IgPSBzZWxlY3RvckNyZWF0b3IoXG4gICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAoLi4uaW5wdXRTZWxlY3RvclJlc3VsdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGlucHV0U2VsZWN0b3JSZXN1bHRzLnJlZHVjZSgoY29tcG9zaXRpb24sIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbXBvc2l0aW9uW2lucHV0U2VsZWN0b3JLZXlzW2luZGV4XV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkU2VsZWN0b3I7XG4gIH0sXG4gIHsgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgfVxuKTtcbmV4cG9ydCB7XG4gIGNyZWF0ZVNlbGVjdG9yLFxuICBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcixcbiAgbHJ1TWVtb2l6ZSxcbiAgcmVmZXJlbmNlRXF1YWxpdHlDaGVjayxcbiAgc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyxcbiAgYXV0b3RyYWNrTWVtb2l6ZSBhcyB1bnN0YWJsZV9hdXRvdHJhY2tNZW1vaXplLFxuICB3ZWFrTWFwTWVtb2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2VsZWN0Lm1qcy5tYXAiXSwibmFtZXMiOlsicnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwicmVzdWx0RnVuYyIsImlucHV0U2VsZWN0b3JzUmVzdWx0cyIsIm91dHB1dFNlbGVjdG9yUmVzdWx0IiwibGVuZ3RoIiwiaXNJbnB1dFNhbWVBc091dHB1dCIsImVtcHR5T2JqZWN0IiwiX3VudXNlZCIsInN0YWNrIiwiRXJyb3IiLCJlIiwiY29uc29sZSIsIndhcm4iLCJydW5JbnB1dFN0YWJpbGl0eUNoZWNrIiwiaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3QiLCJvcHRpb25zIiwiaW5wdXRTZWxlY3RvckFyZ3MiLCJtZW1vaXplIiwibWVtb2l6ZU9wdGlvbnMiLCJpbnB1dFNlbGVjdG9yUmVzdWx0cyIsImlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSIsImNyZWF0ZUFuRW1wdHlPYmplY3QiLCJhcHBseSIsImNvbmNhdCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyZUlucHV0U2VsZWN0b3JSZXN1bHRzRXF1YWwiLCJhcmd1bWVudHMiLCJmaXJzdElucHV0cyIsInNlY29uZElucHV0cyIsImdsb2JhbERldk1vZGVDaGVja3MiLCJpbnB1dFN0YWJpbGl0eUNoZWNrIiwiaWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwic2V0R2xvYmFsRGV2TW9kZUNoZWNrcyIsImRldk1vZGVDaGVja3MiLCJPYmplY3QiLCJhc3NpZ24iLCJOT1RfRk9VTkQiLCJTeW1ib2wiLCJhc3NlcnRJc0Z1bmN0aW9uIiwiZnVuYyIsImVycm9yTWVzc2FnZSIsInVuZGVmaW5lZCIsIl90eXBlb2YiLCJUeXBlRXJyb3IiLCJhc3NlcnRJc09iamVjdCIsIm9iamVjdCIsImFzc2VydElzQXJyYXlPZkZ1bmN0aW9ucyIsImFycmF5IiwiZXZlcnkiLCJpdGVtIiwiaXRlbVR5cGVzIiwibWFwIiwibmFtZSIsImpvaW4iLCJlbnN1cmVJc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RGVwZW5kZW5jaWVzIiwiY3JlYXRlU2VsZWN0b3JBcmdzIiwiZGVwZW5kZW5jaWVzIiwiY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzIiwiaSIsInB1c2giLCJnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mbyIsImZpcnN0UnVuIiwiX2dsb2JhbERldk1vZGVDaGVja3MkIiwiX29iamVjdFNwcmVhZCIsInNob3VsZFJ1biIsInJ1biIsIiRSRVZJU0lPTiIsIkNVUlJFTlRfVFJBQ0tFUiIsIkNlbGwiLCJpbml0aWFsVmFsdWUiLCJpc0VxdWFsIiwidHJpcGxlRXEiLCJfY2xhc3NDYWxsQ2hlY2siLCJyZXZpc2lvbiIsIl92YWx1ZSIsIl9sYXN0VmFsdWUiLCJfaXNFcXVhbCIsIl9jcmVhdGVDbGFzcyIsImtleSIsImdldCIsIl9DVVJSRU5UX1RSQUNLRVIiLCJhZGQiLCJzZXQiLCJuZXdWYWx1ZSIsInZhbHVlIiwiYSIsImIiLCJUcmFja2luZ0NhY2hlIiwiZm4iLCJfY2FjaGVkVmFsdWUiLCJfY2FjaGVkUmV2aXNpb24iLCJfZGVwcyIsImhpdHMiLCJjbGVhciIsIl9DVVJSRU5UX1RSQUNLRVIyIiwiY3VycmVudFRyYWNrZXIiLCJTZXQiLCJwcmV2VHJhY2tlciIsImZyb20iLCJNYXRoIiwibWF4IiwiZCIsImdldFZhbHVlIiwiY2VsbCIsInNldFZhbHVlIiwic3RvcmFnZSIsImNyZWF0ZUNlbGwiLCJjcmVhdGVDYWNoZSIsIm5ldmVyRXEiLCJjcmVhdGVUYWciLCJkaXJ0eVRhZyIsInRhZyIsImNvbnN1bWVDb2xsZWN0aW9uIiwibm9kZSIsImNvbGxlY3Rpb25UYWciLCJkaXJ0eUNvbGxlY3Rpb24iLCJSRURVWF9QUk9YWV9MQUJFTCIsIm5leHRJZCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJPYmplY3RUcmVlTm9kZSIsInByb3h5IiwiUHJveHkiLCJvYmplY3RQcm94eUhhbmRsZXIiLCJ0YWdzIiwiY2hpbGRyZW4iLCJpZCIsImNhbGN1bGF0ZVJlc3VsdCIsImNoaWxkVmFsdWUiLCJSZWZsZWN0IiwiY2hpbGROb2RlIiwiY3JlYXRlTm9kZSIsInJlcyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwcm9wIiwiaGFzIiwiQXJyYXlUcmVlTm9kZSIsImFycmF5UHJveHlIYW5kbGVyIiwiX3JlZiIsIl9yZWYyIiwiX3NsaWNlZFRvQXJyYXkiLCJfcmVmMyIsIl9yZWY0IiwiX3JlZjUiLCJfcmVmNiIsIl9yZWY3IiwiX3JlZjgiLCJ1cGRhdGVOb2RlIiwib2xkS2V5c1NpemUiLCJuZXdLZXlzU2l6ZSIsImFueUtleXNBZGRlZCIsIl9rZXkiLCJpc0RpZmZlcmVudCIsIm5ld0NoaWxkVmFsdWUiLCJkZWxldGVOb2RlIiwiY3JlYXRlU2luZ2xldG9uQ2FjaGUiLCJlcXVhbHMiLCJlbnRyeSIsInB1dCIsImdldEVudHJpZXMiLCJjcmVhdGVMcnVDYWNoZSIsIm1heFNpemUiLCJlbnRyaWVzIiwiY2FjaGVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInVuc2hpZnQiLCJwb3AiLCJyZWZlcmVuY2VFcXVhbGl0eUNoZWNrIiwiY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yIiwiZXF1YWxpdHlDaGVjayIsImFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsIiwicHJldiIsIm5leHQiLCJscnVNZW1vaXplIiwiZXF1YWxpdHlDaGVja09yT3B0aW9ucyIsInByb3ZpZGVkT3B0aW9ucyIsIl9wcm92aWRlZE9wdGlvbnMkZXF1YSIsIl9wcm92aWRlZE9wdGlvbnMkbWF4UyIsInJlc3VsdEVxdWFsaXR5Q2hlY2siLCJjb21wYXJhdG9yIiwicmVzdWx0c0NvdW50IiwiY2FjaGUiLCJtZW1vaXplZCIsIm1hdGNoaW5nRW50cnkiLCJmaW5kIiwiY2xlYXJDYWNoZSIsInJlc2V0UmVzdWx0c0NvdW50IiwiYXV0b3RyYWNrTWVtb2l6ZSIsImxhc3RBcmdzIiwic2hhbGxvd0VxdWFsIiwiU3Ryb25nUmVmIiwiZGVyZWYiLCJSZWYiLCJXZWFrUmVmIiwiVU5URVJNSU5BVEVEIiwiVEVSTUlOQVRFRCIsImNyZWF0ZUNhY2hlTm9kZSIsInMiLCJ2IiwibyIsInAiLCJ3ZWFrTWFwTWVtb2l6ZSIsImZuTm9kZSIsImxhc3RSZXN1bHQiLCJjYWNoZU5vZGUiLCJsIiwiYXJnIiwib2JqZWN0Q2FjaGUiLCJXZWFrTWFwIiwib2JqZWN0Tm9kZSIsInByaW1pdGl2ZUNhY2hlIiwiTWFwIiwicHJpbWl0aXZlTm9kZSIsInRlcm1pbmF0ZWROb2RlIiwicmVzdWx0IiwiX2xhc3RSZXN1bHQkZGVyZWYiLCJfbGFzdFJlc3VsdCIsIl9sYXN0UmVzdWx0JGRlcmVmMiIsImxhc3RSZXN1bHRWYWx1ZSIsImNhbGwiLCJuZWVkc1dlYWtSZWYiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJtZW1vaXplT3JPcHRpb25zIiwiX2xlbiIsIm1lbW9pemVPcHRpb25zRnJvbUFyZ3MiLCJfa2V5NSIsImNyZWF0ZVNlbGVjdG9yQ3JlYXRvck9wdGlvbnMiLCJjcmVhdGVTZWxlY3RvcjIiLCJfbGVuMiIsIl9rZXk2IiwicmVjb21wdXRhdGlvbnMiLCJkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMiLCJkaXJlY3RseVBhc3NlZE9wdGlvbnMiLCJjb21iaW5lZE9wdGlvbnMiLCJfY29tYmluZWRPcHRpb25zJG1lbW8iLCJfY29tYmluZWRPcHRpb25zJGFyZ3MiLCJhcmdzTWVtb2l6ZSIsIl9jb21iaW5lZE9wdGlvbnMkYXJnczIiLCJhcmdzTWVtb2l6ZU9wdGlvbnMiLCJfY29tYmluZWRPcHRpb25zJGRldk0iLCJmaW5hbE1lbW9pemVPcHRpb25zIiwiZmluYWxBcmdzTWVtb2l6ZU9wdGlvbnMiLCJtZW1vaXplZFJlc3VsdEZ1bmMiLCJyZWNvbXB1dGF0aW9uV3JhcHBlciIsInNlbGVjdG9yIiwiZGVwZW5kZW5jaWVzQ2hlY2tlciIsIl9nZXREZXZNb2RlQ2hlY2tzRXhlYyIsInJlc2V0RGVwZW5kZW5jeVJlY29tcHV0YXRpb25zIiwicmVzZXRSZWNvbXB1dGF0aW9ucyIsIndpdGhUeXBlcyIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIiwiaW5wdXRTZWxlY3RvcnNPYmplY3QiLCJzZWxlY3RvckNyZWF0b3IiLCJpbnB1dFNlbGVjdG9yS2V5cyIsImtleXMiLCJzdHJ1Y3R1cmVkU2VsZWN0b3IiLCJfbGVuMyIsIl9rZXk3IiwicmVkdWNlIiwiY29tcG9zaXRpb24iLCJpbmRleCIsInVuc3RhYmxlX2F1dG90cmFja01lbW9pemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reselect/dist/reselect.mjs\n");

/***/ })

};
;