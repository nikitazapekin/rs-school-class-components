"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-redux";
exports.ids = ["vendor-chunks/react-redux"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/with-selector.js\");\nvar _excluded = [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"],\n  _excluded2 = [\"reactReduxForwardedRef\"];\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// src/index.ts\n\n\n\n// src/utils/react.ts\n\nvar React =\n// prettier-ignore\n// @ts-ignore\n true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n// src/components/Context.ts\nvar ContextKey = Symbol[\"for\"](\"react-redux-context\");\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\nfunction getContext() {\n  var _gT$ContextKey;\n  if (!React.createContext) return {};\n  var contextMap = (_gT$ContextKey = gT[ContextKey]) !== null && _gT$ContextKey !== void 0 ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */new Map();\n  var realContext = contextMap.get(React.createContext);\n  if (!realContext) {\n    realContext = React.createContext(null);\n    if (true) {\n      realContext.displayName = \"ReactRedux\";\n    }\n    contextMap.set(React.createContext, realContext);\n  }\n  return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */getContext();\n\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = function notInitialized() {\n  throw new Error(\"uSES not initialized!\");\n};\n\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  return function useReduxContext2() {\n    var contextValue = React.useContext(context);\n    if ( true && !contextValue) {\n      throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n    }\n    return contextValue;\n  };\n}\nvar useReduxContext = /* @__PURE__ */createReduxContextHook();\n\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = function initializeUseSelector(fn) {\n  useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\nfunction createSelectorHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  var useSelector2 = function useSelector2(selector) {\n    var equalityFnOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _ref = typeof equalityFnOrOptions === \"function\" ? {\n        equalityFn: equalityFnOrOptions\n      } : equalityFnOrOptions,\n      _ref$equalityFn = _ref.equalityFn,\n      equalityFn = _ref$equalityFn === void 0 ? refEquality : _ref$equalityFn,\n      _ref$devModeChecks = _ref.devModeChecks,\n      devModeChecks = _ref$devModeChecks === void 0 ? {} : _ref$devModeChecks;\n    if (true) {\n      if (!selector) {\n        throw new Error(\"You must pass a selector to useSelector\");\n      }\n      if (typeof selector !== \"function\") {\n        throw new Error(\"You must pass a function as a selector to useSelector\");\n      }\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(\"You must pass a function as an equality function to useSelector\");\n      }\n    }\n    var _useReduxContext = useReduxContext2(),\n      store = _useReduxContext.store,\n      subscription = _useReduxContext.subscription,\n      getServerState = _useReduxContext.getServerState,\n      stabilityCheck = _useReduxContext.stabilityCheck,\n      identityFunctionCheck = _useReduxContext.identityFunctionCheck;\n    var firstRun = React.useRef(true);\n    var wrappedSelector = React.useCallback(_defineProperty({}, selector.name, function (state) {\n      var selected = selector(state);\n      if (true) {\n        var _stabilityCheck$ident = _objectSpread({\n            stabilityCheck: stabilityCheck,\n            identityFunctionCheck: identityFunctionCheck\n          }, devModeChecks),\n          finalIdentityFunctionCheck = _stabilityCheck$ident.identityFunctionCheck,\n          finalStabilityCheck = _stabilityCheck$ident.stabilityCheck;\n        if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n          var toCompare = selector(state);\n          if (!equalityFn(selected, toCompare)) {\n            var stack = void 0;\n            try {\n              throw new Error();\n            } catch (e) {\n              ;\n              stack = e.stack;\n            }\n            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n              state: state,\n              selected: selected,\n              selected2: toCompare,\n              stack: stack\n            });\n          }\n        }\n        if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n          if (selected === state) {\n            var _stack = void 0;\n            try {\n              throw new Error();\n            } catch (e) {\n              ;\n              _stack = e.stack;\n            }\n            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n              stack: _stack\n            });\n          }\n        }\n        if (firstRun.current) firstRun.current = false;\n      }\n      return selected;\n    })[selector.name], [selector, stabilityCheck, devModeChecks.stabilityCheck]);\n    var selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    React.useDebugValue(selectedState);\n    return selectedState;\n  };\n  Object.assign(useSelector2, {\n    withTypes: function withTypes() {\n      return useSelector2;\n    }\n  });\n  return useSelector2;\n}\nvar useSelector = /* @__PURE__ */createSelectorHook();\n\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol[\"for\"](\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol[\"for\"](\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol[\"for\"](\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol[\"for\"](\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol[\"for\"](\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol[\"for\"](\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol[\"for\"](\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol[\"for\"](\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol[\"for\"](\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol[\"for\"](\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol[\"for\"](\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol[\"for\"](\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol[\"for\"](\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol[\"for\"](\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol[\"for\"](\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n  if (typeof type === \"string\" || typeof type === \"function\") {\n    return true;\n  }\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n    return true;\n  }\n  if (_typeof(type) === \"object\" && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n    // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction typeOf(object) {\n  if (_typeof(object) === \"object\" && object !== null) {\n    var $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        {\n          var type = object.type;\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n              return type;\n            default:\n              {\n                var $$typeofType = type && type.$$typeof;\n                switch ($$typeofType) {\n                  case REACT_SERVER_CONTEXT_TYPE:\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                  case REACT_PROVIDER_TYPE:\n                    return $$typeofType;\n                  default:\n                    return $$typeof;\n                }\n              }\n          }\n        }\n      case REACT_PORTAL_TYPE:\n        {\n          return $$typeof;\n        }\n    }\n  }\n  return void 0;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {}\n}\n\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(\"Unexpected value for \".concat(methodName, \" in connect.\"));\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(\"The selector for \".concat(methodName, \" of connect did not specify a value for dependsOnOwnProps.\"));\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n}\n\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref2) {\n  var areStatesEqual = _ref2.areStatesEqual,\n    areOwnPropsEqual = _ref2.areOwnPropsEqual,\n    areStatePropsEqual = _ref2.areStatePropsEqual;\n  var hasRunAtLeastOnce = false;\n  var state;\n  var ownProps;\n  var stateProps;\n  var dispatchProps;\n  var mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    var nextStateProps = mapStateToProps(state, ownProps);\n    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\nfunction finalPropsSelectorFactory(dispatch, _ref3) {\n  var initMapStateToProps = _ref3.initMapStateToProps,\n    initMapDispatchToProps = _ref3.initMapDispatchToProps,\n    initMergeProps = _ref3.initMergeProps,\n    options = _objectWithoutProperties(_ref3, _excluded);\n  var mapStateToProps = initMapStateToProps(dispatch, options);\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  var mergeProps = initMergeProps(dispatch, options);\n  if (true) {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n  var boundActionCreators = {};\n  var _loop = function _loop() {\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = function () {\n        return dispatch(actionCreator.apply(void 0, arguments));\n      };\n    }\n  };\n  for (var key in actionCreators) {\n    _loop();\n  }\n  return boundActionCreators;\n}\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (_typeof(obj) !== \"object\" || obj === null) return false;\n  var proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  var baseProto = proto;\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n  return proto === baseProto;\n}\n\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(\"\".concat(methodName, \"() in \").concat(displayName, \" must return a plain object. Instead received \").concat(value, \".\"));\n  }\n}\n\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    var constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref4) {\n    var displayName = _ref4.displayName;\n    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      var props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (true) verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n    return proxy;\n  };\n}\n\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n  return function (dispatch, options) {\n    throw new Error(\"Invalid value of type \".concat(_typeof(arg), \" for \").concat(name, \" argument when connecting component \").concat(options.wrappedComponentName, \".\"));\n  };\n}\n\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && _typeof(mapDispatchToProps) === \"object\" ? wrapMapToPropsConstant(function (dispatch) {\n    return (\n      // @ts-ignore\n      bindActionCreators(mapDispatchToProps, dispatch)\n    );\n  }) : !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {\n    return {\n      dispatch: dispatch\n    };\n  }) : typeof mapDispatchToProps === \"function\" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(function () {\n    return {};\n  }) : typeof mapStateToProps === \"function\" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return _objectSpread(_objectSpread(_objectSpread({}, ownProps), stateProps), dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, _ref5) {\n    var displayName = _ref5.displayName,\n      areMergedPropsEqual = _ref5.areMergedPropsEqual;\n    var hasRunOnce = false;\n    var mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? function () {\n    return defaultMergeProps;\n  } : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n  var first = null;\n  var last = null;\n  return {\n    clear: function clear() {\n      first = null;\n      last = null;\n    },\n    notify: function notify() {\n      defaultNoopBatch(function () {\n        var listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get: function get() {\n      var listeners = [];\n      var listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe: function subscribe(callback) {\n      var isSubscribed = true;\n      var listener = last = {\n        callback: callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify: function notify() {},\n  get: function get() {\n    return [];\n  }\n};\nfunction createSubscription(store, parentSub) {\n  var unsubscribe;\n  var listeners = nullListeners;\n  var subscriptionsAmount = 0;\n  var selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    var cleanupListener = listeners.subscribe(listener);\n    var removed = false;\n    return function () {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  var subscription = {\n    addNestedSub: addNestedSub,\n    notifyNestedSubs: notifyNestedSubs,\n    handleChangeWrapper: handleChangeWrapper,\n    isSubscribed: isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: function getListeners() {\n      return listeners;\n    }\n  };\n  return subscription;\n}\n\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!( false && 0);\nvar isReactNative = typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;\n\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n  if (_typeof(objA) !== \"object\" || objA === null || _typeof(objB) !== \"object\" || objB === null) {\n    return false;\n  }\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n  for (var i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = _defineProperty(_defineProperty({}, ForwardRef, FORWARD_REF_STATICS), Memo, MEMO_STATICS);\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n    var keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n  return targetComponent;\n}\n\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = function initializeConnect(fn) {\n  useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\nvar stringifyComponent = function stringifyComponent(Comp) {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(function () {\n    return effectFunc.apply(void 0, _toConsumableArray(effectArgs));\n  }, dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return function () {};\n  var didUnsubscribe = false;\n  var lastThrownError = null;\n  var checkForUpdates = function checkForUpdates() {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n    var latestStoreState = store.getState();\n    var newChildProps, error;\n    try {\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    }\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n  var unsubscribeWrapper = function unsubscribeWrapper() {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n  return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n  var _ref6 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    pure = _ref6.pure,\n    _ref6$areStatesEqual = _ref6.areStatesEqual,\n    areStatesEqual = _ref6$areStatesEqual === void 0 ? strictEqual : _ref6$areStatesEqual,\n    _ref6$areOwnPropsEqua = _ref6.areOwnPropsEqual,\n    areOwnPropsEqual = _ref6$areOwnPropsEqua === void 0 ? shallowEqual : _ref6$areOwnPropsEqua,\n    _ref6$areStatePropsEq = _ref6.areStatePropsEqual,\n    areStatePropsEqual = _ref6$areStatePropsEq === void 0 ? shallowEqual : _ref6$areStatePropsEq,\n    _ref6$areMergedPropsE = _ref6.areMergedPropsEqual,\n    areMergedPropsEqual = _ref6$areMergedPropsE === void 0 ? shallowEqual : _ref6$areMergedPropsE,\n    _ref6$forwardRef = _ref6.forwardRef,\n    forwardRef = _ref6$forwardRef === void 0 ? false : _ref6$forwardRef,\n    _ref6$context = _ref6.context,\n    context = _ref6$context === void 0 ? ReactReduxContext : _ref6$context;\n  if (true) {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n    }\n  }\n  var Context = context;\n  var initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  var initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  var initMergeProps = mergePropsFactory(mergeProps);\n  var shouldHandleStateChanges = Boolean(mapStateToProps);\n  var wrapWithConnect = function wrapWithConnect(WrappedComponent) {\n    if (true) {\n      var isValid = /* @__PURE__ */isValidElementType(WrappedComponent);\n      if (!isValid) throw new Error(\"You must pass a component to the function returned by connect. Instead received \".concat(stringifyComponent(WrappedComponent)));\n    }\n    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    var displayName = \"Connect(\".concat(wrappedComponentName, \")\");\n    var selectorFactoryOptions = {\n      shouldHandleStateChanges: shouldHandleStateChanges,\n      displayName: displayName,\n      wrappedComponentName: wrappedComponentName,\n      WrappedComponent: WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps: initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps: initMapDispatchToProps,\n      initMergeProps: initMergeProps,\n      areStatesEqual: areStatesEqual,\n      areStatePropsEqual: areStatePropsEqual,\n      areOwnPropsEqual: areOwnPropsEqual,\n      areMergedPropsEqual: areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      var _React$useMemo = React.useMemo(function () {\n          var reactReduxForwardedRef2 = props.reactReduxForwardedRef,\n            wrapperProps2 = _objectWithoutProperties(props, _excluded2);\n          return [props.context, reactReduxForwardedRef2, wrapperProps2];\n        }, [props]),\n        _React$useMemo2 = _slicedToArray(_React$useMemo, 3),\n        propsContext = _React$useMemo2[0],\n        reactReduxForwardedRef = _React$useMemo2[1],\n        wrapperProps = _React$useMemo2[2];\n      var ContextToUse = React.useMemo(function () {\n        var ResultContext = Context;\n        if (propsContext !== null && propsContext !== void 0 && propsContext.Consumer) {\n          if (true) {\n            var _isValid = /* @__PURE__ */isContextConsumer(\n            // @ts-ignore\n            /* @__PURE__ */\n            React.createElement(propsContext.Consumer, null));\n            if (!_isValid) {\n              throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n            }\n            ResultContext = propsContext;\n          }\n        }\n        return ResultContext;\n      }, [propsContext, Context]);\n      var contextValue = React.useContext(ContextToUse);\n      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(\"Could not find \\\"store\\\" in the context of \\\"\".concat(displayName, \"\\\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to \").concat(displayName, \" in connect options.\"));\n      }\n      var store = didStoreComeFromProps ? props.store : contextValue.store;\n      var getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      var childPropsSelector = React.useMemo(function () {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      var _React$useMemo3 = React.useMemo(function () {\n          if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n          var subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n          var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n          return [subscription2, notifyNestedSubs2];\n        }, [store, didStoreComeFromProps, contextValue]),\n        _React$useMemo4 = _slicedToArray(_React$useMemo3, 2),\n        subscription = _React$useMemo4[0],\n        notifyNestedSubs = _React$useMemo4[1];\n      var overriddenContextValue = React.useMemo(function () {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n        return _objectSpread(_objectSpread({}, contextValue), {}, {\n          subscription: subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      var lastChildProps = React.useRef(void 0);\n      var lastWrapperProps = React.useRef(wrapperProps);\n      var childPropsFromStoreUpdate = React.useRef(void 0);\n      var renderIsScheduled = React.useRef(false);\n      var isMounted = React.useRef(false);\n      var latestSubscriptionCallbackError = React.useRef(void 0);\n      useIsomorphicLayoutEffect(function () {\n        isMounted.current = true;\n        return function () {\n          isMounted.current = false;\n        };\n      }, []);\n      var actualChildPropsSelector = React.useMemo(function () {\n        var selector = function selector() {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]);\n      var subscribeForReact = React.useMemo(function () {\n        var subscribe = function subscribe(reactListener) {\n          if (!subscription) {\n            return function () {};\n          }\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription,\n          // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      var actualChildProps;\n      try {\n        actualChildProps = useSyncExternalStore(\n        // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact,\n        // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? function () {\n          return childPropsSelector(getServerState(), wrapperProps);\n        } : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(function () {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      var renderedWrappedComponent = React.useMemo(function () {\n        return (\n          // @ts-ignore\n          /* @__PURE__ */\n          React.createElement(WrappedComponent, _objectSpread(_objectSpread({}, actualChildProps), {}, {\n            ref: reactReduxForwardedRef\n          }))\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      var renderedChild = React.useMemo(function () {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    var _Connect = React.memo(ConnectFunction);\n    var Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      var _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        return /* @__PURE__ */React.createElement(Connect, _objectSpread(_objectSpread({}, props), {}, {\n          reactReduxForwardedRef: ref\n        }));\n      });\n      var forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n    return /* @__PURE__ */hoistNonReactStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\nvar connect_default = connect;\n\n// src/components/Provider.tsx\nfunction Provider(_ref7) {\n  var store = _ref7.store,\n    context = _ref7.context,\n    children = _ref7.children,\n    serverState = _ref7.serverState,\n    _ref7$stabilityCheck = _ref7.stabilityCheck,\n    stabilityCheck = _ref7$stabilityCheck === void 0 ? \"once\" : _ref7$stabilityCheck,\n    _ref7$identityFunctio = _ref7.identityFunctionCheck,\n    identityFunctionCheck = _ref7$identityFunctio === void 0 ? \"once\" : _ref7$identityFunctio;\n  var contextValue = React.useMemo(function () {\n    var subscription = createSubscription(store);\n    return {\n      store: store,\n      subscription: subscription,\n      getServerState: serverState ? function () {\n        return serverState;\n      } : void 0,\n      stabilityCheck: stabilityCheck,\n      identityFunctionCheck: identityFunctionCheck\n    };\n  }, [store, serverState, stabilityCheck, identityFunctionCheck]);\n  var previousState = React.useMemo(function () {\n    return store.getState();\n  }, [store]);\n  useIsomorphicLayoutEffect(function () {\n    var subscription = contextValue.subscription;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return function () {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  var Context = context || ReactReduxContext;\n  return /* @__PURE__ */React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\nvar Provider_default = Provider;\n\n// src/hooks/useStore.ts\nfunction createStoreHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useReduxContext2 = context === ReactReduxContext ? useReduxContext :\n  // @ts-ignore\n  createReduxContextHook(context);\n  var useStore2 = function useStore2() {\n    var _useReduxContext2 = useReduxContext2(),\n      store = _useReduxContext2.store;\n    return store;\n  };\n  Object.assign(useStore2, {\n    withTypes: function withTypes() {\n      return useStore2;\n    }\n  });\n  return useStore2;\n}\nvar useStore = /* @__PURE__ */createStoreHook();\n\n// src/hooks/useDispatch.ts\nfunction createDispatchHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n  var useDispatch2 = function useDispatch2() {\n    var store = useStore2();\n    return store.dispatch;\n  };\n  Object.assign(useDispatch2, {\n    withTypes: function withTypes() {\n      return useDispatch2;\n    }\n  });\n  return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */createDispatchHook();\n\n// src/exports.ts\nvar batch = defaultNoopBatch;\n\n// src/index.ts\ninitializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\ninitializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2dDO0FBQ2lHOztBQUVqSTtBQUN1QztBQUN2QyxJQUFJSSxLQUFLO0FBQ1A7QUFDQTtBQUNBLEtBQTBCLEdBQUdELGtDQUF3QixHQUFHQSx5TEFDekQ7O0FBRUQ7QUFDQSxJQUFJRSxVQUFVLEdBQUdDLE1BQU0sT0FBSSxzQkFBc0IsQ0FBQztBQUNsRCxJQUFJQyxFQUFFLEdBQUcsT0FBT0MsVUFBVSxLQUFLLFdBQVcsR0FBR0EsVUFBVSxHQUNyRDtBQUNBLENBQUMsQ0FDRjtBQUNELFNBQVNDLFVBQVVBLENBQUEsRUFBRztFQUFBLElBQUFDLGNBQUE7RUFDcEIsSUFBSSxDQUFDTixLQUFLLENBQUNPLGFBQWEsRUFDdEIsT0FBTyxDQUFDLENBQUM7RUFDWCxJQUFNQyxVQUFVLElBQUFGLGNBQUEsR0FBR0gsRUFBRSxDQUFDRixVQUFVLENBQUMsY0FBQUssY0FBQSxjQUFBQSxjQUFBLEdBQUtILEVBQUUsQ0FBQ0YsVUFBVSxDQUFDLEdBQUcsZUFBZ0IsSUFBSVEsR0FBRyxDQUFDLENBQUU7RUFDakYsSUFBSUMsV0FBVyxHQUFHRixVQUFVLENBQUNHLEdBQUcsQ0FBQ1gsS0FBSyxDQUFDTyxhQUFhLENBQUM7RUFDckQsSUFBSSxDQUFDRyxXQUFXLEVBQUU7SUFDaEJBLFdBQVcsR0FBR1YsS0FBSyxDQUFDTyxhQUFhLENBQy9CLElBQ0YsQ0FBQztJQUNELElBQUksTUFBdUM7TUFDekNHLFdBQVcsQ0FBQ0UsV0FBVyxHQUFHLFlBQVk7SUFDeEM7SUFDQUosVUFBVSxDQUFDSyxHQUFHLENBQUNiLEtBQUssQ0FBQ08sYUFBYSxFQUFFRyxXQUFXLENBQUM7RUFDbEQ7RUFDQSxPQUFPQSxXQUFXO0FBQ3BCO0FBQ0EsSUFBSUksaUJBQWlCLEdBQUcsZUFBZ0JULFVBQVUsQ0FB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T0FBT0EsU0FBUztBQUNsQjtBQUNBLElBQUlFLFFBQVEsR0FBRyxlQUFnQkgsZUFBZSxDQUFDLENBQUM7O0FBRWhEO0FBQ0EsU0FBU0ksa0JBQWtCQSxDQUFBLEVBQThCO0VBQUEsSUFBN0JoVyxPQUFPLEdBQUFDLFNBQUEsQ0FBQUMsTUFBQSxRQUFBRCxTQUFBLFFBQUFFLFNBQUEsR0FBQUYsU0FBQSxNQUFHTCxpQkFBaUI7RUFDckQsSUFBTWlXLFNBQVMsR0FBRzdWLE9BQU8sS0FBS0osaUJBQWlCLEdBQUdtVyxRQUFRLEdBQUdILGVBQWUsQ0FBQzVWLE9BQU8sQ0FBQztFQUNyRixJQUFNaVcsWUFBWSxHQUFHLFNBQWZBLFlBQVlBLENBQUEsRUFBUztJQUN6QixJQUFNMVUsS0FBSyxHQUFHc1UsU0FBUyxDQUFDLENBQUM7SUFDekIsT0FBT3RVLEtBQUssQ0FBQ3lFLFFBQVE7RUFDdkIsQ0FBQztFQUNEN0MsTUFBTSxDQUFDQyxNQUFNLENBQUM2UyxZQUFZLEVBQUU7SUFDMUI1UyxTQUFTLEVBQUUsU0FBWEEsU0FBU0EsQ0FBQTtNQUFBLE9BQVE0UyxZQUFZO0lBQUE7RUFDL0IsQ0FBQyxDQUFDO0VBQ0YsT0FBT0EsWUFBWTtBQUNyQjtBQUNBLElBQUlDLFdBQVcsR0FBRyxlQUFnQkYsa0JBQWtCLENBQUMsQ0FBQzs7QUFFdEQ7QUFDQSxJQUFJRyxLQUFLLEdBQUd0TCxnQkFBZ0I7O0FBRTVCO0FBQ0FySyxxQkFBcUIsQ0FBQzVCLHNHQUFpQyxDQUFDO0FBQ3hEcVIsaUJBQWlCLENBQUN2Uix1REFBMkIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LXRlc3Qtc2V0dXAvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanM/MDQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy91dGlscy9yZWFjdC50c1xuaW1wb3J0ICogYXMgUmVhY3RPcmlnaW5hbCBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdCA9IChcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEB0cy1pZ25vcmVcbiAgXCJkZWZhdWx0XCIgaW4gUmVhY3RPcmlnaW5hbCA/IFJlYWN0T3JpZ2luYWxbXCJkZWZhdWx0XCJdIDogUmVhY3RPcmlnaW5hbFxuKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvQ29udGV4dC50c1xudmFyIENvbnRleHRLZXkgPSBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XG52YXIgZ1QgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiAoXG4gIC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xuICB7fVxuKTtcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dClcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IGNvbnRleHRNYXAgPSBnVFtDb250ZXh0S2V5XSA/PyAoZ1RbQ29udGV4dEtleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG4gIGlmICghcmVhbENvbnRleHQpIHtcbiAgICByZWFsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUmVhY3RSZWR1eFwiO1xuICAgIH1cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIHJlYWxDb250ZXh0O1xufVxudmFyIFJlYWN0UmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGdldENvbnRleHQoKTtcblxuLy8gc3JjL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlLnRzXG52YXIgbm90SW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcInVTRVMgbm90IGluaXRpYWxpemVkIVwiKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2VSZWR1eENvbnRleHQudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQyKCkge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gIH07XG59XG52YXIgdXNlUmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVNlbGVjdG9yLnRzXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBub3RJbml0aWFsaXplZDtcbnZhciBpbml0aWFsaXplVXNlU2VsZWN0b3IgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmbjtcbn07XG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuT3JPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSwgZGV2TW9kZUNoZWNrcyA9IHt9IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVxdWFsaXR5Rm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjazogZmluYWxTdGFiaWxpdHlDaGVja1xuICAgICAgICAgICAgfSA9IHtcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgLi4uZGV2TW9kZUNoZWNrc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9Db21wYXJlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiBhIG5ldyByZWZlcmVuY2UgKHN1Y2ggYXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5KSBzaG91bGQgYmUgbWVtb2l6ZWQ6IGh0dHBzOi8vcmVkdXguanMub3JnL3VzYWdlL2Rlcml2aW5nLWRhdGEtc2VsZWN0b3JzI29wdGltaXppbmctc2VsZWN0b3JzLXdpdGgtbWVtb2l6YXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiB0aGUgZW50aXJlIHN0YXRlIGFyZSBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSwgYXMgdGhleSB3aWxsIGNhdXNlIGEgcmVyZW5kZXIgd2hlbmV2ZXIgKmFueXRoaW5nKiBpbiBzdGF0ZSBjaGFuZ2VzLlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGFjayB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0UnVuLmN1cnJlbnQpXG4gICAgICAgICAgICAgIGZpcnN0UnVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9W3NlbGVjdG9yLm5hbWVdLFxuICAgICAgW3NlbGVjdG9yLCBzdGFiaWxpdHlDaGVjaywgZGV2TW9kZUNoZWNrcy5zdGFiaWxpdHlDaGVja11cbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmlwdGlvbi5hZGROZXN0ZWRTdWIsXG4gICAgICBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgZXF1YWxpdHlGblxuICAgICk7XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIHVzZVNlbGVjdG9yMjtcbn1cbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcblxuLy8gc3JjL3V0aWxzL3JlYWN0LWlzLnRzXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRToge1xuICAgICAgICBjb25zdCB0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLnRzXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgJHttZXRob2ROYW1lfSBpbiBjb25uZWN0LmApO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09IFwibWFwU3RhdGVUb1Byb3BzXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJtYXBEaXNwYXRjaFRvUHJvcHNcIikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCBcImRlcGVuZHNPbk93blByb3BzXCIpKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgVGhlIHNlbGVjdG9yIGZvciAke21ldGhvZE5hbWV9IG9mIGNvbm5lY3QgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkudHNcbmZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwge1xuICBhcmVTdGF0ZXNFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsXG59KSB7XG4gIGxldCBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGxldCBvd25Qcm9wcztcbiAgbGV0IHN0YXRlUHJvcHM7XG4gIGxldCBkaXNwYXRjaFByb3BzO1xuICBsZXQgbWVyZ2VkUHJvcHM7XG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChcbiAgICAgIG5leHRTdGF0ZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbmV4dE93blByb3BzLFxuICAgICAgb3duUHJvcHNcbiAgICApO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwge1xuICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICBpbml0TWVyZ2VQcm9wcyxcbiAgLi4ub3B0aW9uc1xufSkge1xuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpO1xuICB9XG4gIHJldHVybiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICBjb25zdCBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gKC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IoLi4uYXJncykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgbGV0IGJhc2VQcm90byA9IHByb3RvO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcbn1cblxuLy8gc3JjL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCkge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gpO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59XG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KGFyZywgbmFtZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lfS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwib2JqZWN0XCIgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KFxuICAgIChkaXNwYXRjaCkgPT4gKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpXG4gICAgKVxuICApIDogIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKGRpc3BhdGNoKSA9PiAoe1xuICAgIGRpc3BhdGNoXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCgpID0+ICh7fSkpIDogdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWVyZ2VQcm9wcy50c1xuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHsgLi4ub3duUHJvcHMsIC4uLnN0YXRlUHJvcHMsIC4uLmRpc3BhdGNoUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lLCBhcmVNZXJnZWRQcm9wc0VxdWFsIH0pIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIGxldCBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSlcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsIFwibWVyZ2VQcm9wc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy91dGlscy9iYXRjaC50c1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG4vLyBzcmMvdXRpbHMvU3Vic2NyaXB0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG4gICAgbm90aWZ5KCkge1xuICAgICAgZGVmYXVsdE5vb3BCYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5KCkge1xuICB9LFxuICBnZXQ6ICgpID0+IFtdXG59O1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIpIHtcbiAgbGV0IHVuc3Vic2NyaWJlO1xuICBsZXQgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgbGV0IHN1YnNjcmlwdGlvbnNBbW91bnQgPSAwO1xuICBsZXQgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgY29uc3QgY2xlYW51cExpc3RlbmVyID0gbGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZW1vdmVkKSB7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50Kys7XG4gICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgdW5zdWJzY3JpYmUgPSBwYXJlbnRTdWIgPyBwYXJlbnRTdWIuYWRkTmVzdGVkU3ViKGhhbmRsZUNoYW5nZVdyYXBwZXIpIDogc3RvcmUuc3Vic2NyaWJlKGhhbmRsZUNoYW5nZVdyYXBwZXIpO1xuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLTtcbiAgICBpZiAodW5zdWJzY3JpYmUgJiYgc3Vic2NyaXB0aW9uc0Ftb3VudCA9PT0gMCkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gdm9pZCAwO1xuICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmICghc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgIGFkZE5lc3RlZFN1YixcbiAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXG4gICAgaXNTdWJzY3JpYmVkLFxuICAgIHRyeVN1YnNjcmliZTogdHJ5U3Vic2NyaWJlU2VsZixcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBzdWJzY3JpcHRpb247XG59XG5cbi8vIHNyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIik7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5cbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2hvaXN0U3RhdGljcy50c1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1Ncbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9XG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50W1wiJCR0eXBlb2ZcIl1dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgY29uc3Qgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeFxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZUNvbm5lY3QgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBmbjtcbn07XG52YXIgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdO1xudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUgfHwgIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihcbiAgICAgICAgbGF0ZXN0U3RvcmVTdGF0ZSxcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTtcbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgY2hlY2tGb3JVcGRhdGVzKCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59XG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIHtcbiAgLy8gVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCwgc28gVFMgZG9lc24ndCBsaWtlIHVzIGRlc3RydWN0dXJpbmcgdGhpcyB0byBjaGVjayBpdHMgZXhpc3RlbmNlLlxuICAvLyBAdHMtaWdub3JlXG4gIHB1cmUsXG4gIGFyZVN0YXRlc0VxdWFsID0gc3RyaWN0RXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gIGZvcndhcmRSZWYgPSBmYWxzZSxcbiAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxufSA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAocHVyZSAhPT0gdm9pZCAwICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0O1xuICBjb25zdCBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICBjb25zdCBpbml0TWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpO1xuICBjb25zdCBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc1ZhbGlkRWxlbWVudFR5cGUoV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3N0cmluZ2lmeUNvbXBvbmVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYENvbm5lY3QoJHt3cmFwcGVkQ29tcG9uZW50TmFtZX0pYDtcbiAgICBjb25zdCBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0ge1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzLFxuICAgICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICAgIH07XG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIC4uLndyYXBwZXJQcm9wczIgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCB3cmFwcGVyUHJvcHMyXTtcbiAgICAgIH0sIFtwcm9wc10pO1xuICAgICAgY29uc3QgQ29udGV4dFRvVXNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBSZXN1bHRDb250ZXh0ID0gQ29udGV4dDtcbiAgICAgICAgaWYgKHByb3BzQ29udGV4dD8uQ29uc3VtZXIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzQ29udGV4dENvbnN1bWVyKFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHRDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0VG9Vc2UpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICBjb25zdCBnZXRTZXJ2ZXJTdGF0ZSA9IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID8gY29udGV4dFZhbHVlLmdldFNlcnZlclN0YXRlIDogc3RvcmUuZ2V0U3RhdGU7XG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcylcbiAgICAgICAgICByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHZvaWQgMCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3ViczIgPSBzdWJzY3JpcHRpb24yLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24yKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24yLCBub3RpZnlOZXN0ZWRTdWJzMl07XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZihcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChyZWFjdExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnNcbiAgICAgIF0pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxuXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmFjdHVhbENoaWxkUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sIFtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCBXcmFwcGVkQ29tcG9uZW50LCBhY3R1YWxDaGlsZFByb3BzXSk7XG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7IHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfVxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pO1xuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgeyAuLi5wcm9wcywgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0O1xufVxudmFyIGNvbm5lY3RfZGVmYXVsdCA9IGNvbm5lY3Q7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZpZGVyLnRzeFxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHNlcnZlclN0YXRlLFxuICBzdGFiaWxpdHlDaGVjayA9IFwib25jZVwiLFxuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPSBcIm9uY2VcIlxufSkge1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdm9pZCAwLFxuICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9O1xuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlLCBzdGFiaWxpdHlDaGVjaywgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXSk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHN0b3JlLmdldFN0YXRlKCksIFtzdG9yZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHZvaWQgMDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcbn1cbnZhciBQcm92aWRlcl9kZWZhdWx0ID0gUHJvdmlkZXI7XG5cbi8vIHNyYy9ob29rcy91c2VTdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmVIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dClcbiAgKTtcbiAgY29uc3QgdXNlU3RvcmUyID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU3RvcmUyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTdG9yZTJcbiAgfSk7XG4gIHJldHVybiB1c2VTdG9yZTI7XG59XG52YXIgdXNlU3RvcmUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU3RvcmVIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VEaXNwYXRjaC50c1xuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VTdG9yZTIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVN0b3JlIDogY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpO1xuICBjb25zdCB1c2VEaXNwYXRjaDIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZTIoKTtcbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2g7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlRGlzcGF0Y2gyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VEaXNwYXRjaDJcbiAgfSk7XG4gIHJldHVybiB1c2VEaXNwYXRjaDI7XG59XG52YXIgdXNlRGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGlzcGF0Y2hIb29rKCk7XG5cbi8vIHNyYy9leHBvcnRzLnRzXG52YXIgYmF0Y2ggPSBkZWZhdWx0Tm9vcEJhdGNoO1xuXG4vLyBzcmMvaW5kZXgudHNcbmluaXRpYWxpemVVc2VTZWxlY3Rvcih1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIpO1xuaW5pdGlhbGl6ZUNvbm5lY3QoUmVhY3QyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKTtcbmV4cG9ydCB7XG4gIFByb3ZpZGVyX2RlZmF1bHQgYXMgUHJvdmlkZXIsXG4gIFJlYWN0UmVkdXhDb250ZXh0LFxuICBiYXRjaCxcbiAgY29ubmVjdF9kZWZhdWx0IGFzIGNvbm5lY3QsXG4gIGNyZWF0ZURpc3BhdGNoSG9vayxcbiAgY3JlYXRlU2VsZWN0b3JIb29rLFxuICBjcmVhdGVTdG9yZUhvb2ssXG4gIHNoYWxsb3dFcXVhbCxcbiAgdXNlRGlzcGF0Y2gsXG4gIHVzZVNlbGVjdG9yLFxuICB1c2VTdG9yZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJlZHV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QyIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIiLCJSZWFjdE9yaWdpbmFsIiwiUmVhY3QiLCJDb250ZXh0S2V5IiwiU3ltYm9sIiwiZ1QiLCJnbG9iYWxUaGlzIiwiZ2V0Q29udGV4dCIsIl9nVCRDb250ZXh0S2V5IiwiY3JlYXRlQ29udGV4dCIsImNvbnRleHRNYXAiLCJNYXAiLCJyZWFsQ29udGV4dCIsImdldCIsImRpc3BsYXlOYW1lIiwic2V0IiwiUmVhY3RSZWR1eENvbnRleHQiLCJub3RJbml0aWFsaXplZCIsIkVycm9yIiwiY3JlYXRlUmVkdXhDb250ZXh0SG9vayIsImNvbnRleHQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ1c2VSZWR1eENvbnRleHQyIiwiY29udGV4dFZhbHVlIiwidXNlQ29udGV4dCIsInVzZVJlZHV4Q29udGV4dCIsImluaXRpYWxpemVVc2VTZWxlY3RvciIsImZuIiwicmVmRXF1YWxpdHkiLCJhIiwiYiIsImNyZWF0ZVNlbGVjdG9ySG9vayIsInVzZVNlbGVjdG9yMiIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbk9yT3B0aW9ucyIsIl9yZWYiLCJlcXVhbGl0eUZuIiwiX3JlZiRlcXVhbGl0eUZuIiwiX3JlZiRkZXZNb2RlQ2hlY2tzIiwiZGV2TW9kZUNoZWNrcyIsIl91c2VSZWR1eENvbnRleHQiLCJzdG9yZSIsInN1YnNjcmlwdGlvbiIsImdldFNlcnZlclN0YXRlIiwic3RhYmlsaXR5Q2hlY2siLCJpZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJmaXJzdFJ1biIsInVzZVJlZiIsIndyYXBwZWRTZWxlY3RvciIsInVzZUNhbGxiYWNrIiwiX2RlZmluZVByb3BlcnR5IiwibmFtZSIsInN0YXRlIiwic2VsZWN0ZWQiLCJfc3RhYmlsaXR5Q2hlY2skaWRlbnQiLCJfb2JqZWN0U3ByZWFkIiwiZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJmaW5hbFN0YWJpbGl0eUNoZWNrIiwiY3VycmVudCIsInRvQ29tcGFyZSIsInN0YWNrIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwic2VsZWN0ZWQyIiwic2VsZWN0ZWRTdGF0ZSIsImFkZE5lc3RlZFN1YiIsImdldFN0YXRlIiwidXNlRGVidWdWYWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsIndpdGhUeXBlcyIsInVzZVNlbGVjdG9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiRm9yd2FyZFJlZiIsIk1lbW8iLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiX3R5cGVvZiIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ0eXBlT2YiLCJvYmplY3QiLCIkJHR5cGVvZlR5cGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzTWVtbyIsIndhcm5pbmciLCJtZXNzYWdlIiwiZXJyb3IiLCJ2ZXJpZnkiLCJtZXRob2ROYW1lIiwiY29uY2F0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmVyaWZ5U3Vic2VsZWN0b3JzIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiZGlzcGF0Y2giLCJfcmVmMiIsImFyZVN0YXRlc0VxdWFsIiwiYXJlT3duUHJvcHNFcXVhbCIsImFyZVN0YXRlUHJvcHNFcXVhbCIsImhhc1J1bkF0TGVhc3RPbmNlIiwib3duUHJvcHMiLCJzdGF0ZVByb3BzIiwiZGlzcGF0Y2hQcm9wcyIsIm1lcmdlZFByb3BzIiwiaGFuZGxlRmlyc3RDYWxsIiwiZmlyc3RTdGF0ZSIsImZpcnN0T3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlIiwiZGVwZW5kc09uT3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wcyIsImhhbmRsZU5ld1N0YXRlIiwibmV4dFN0YXRlUHJvcHMiLCJzdGF0ZVByb3BzQ2hhbmdlZCIsImhhbmRsZVN1YnNlcXVlbnRDYWxscyIsIm5leHRTdGF0ZSIsIm5leHRPd25Qcm9wcyIsInByb3BzQ2hhbmdlZCIsInN0YXRlQ2hhbmdlZCIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3IiLCJmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiX3JlZjMiLCJpbml0TWFwU3RhdGVUb1Byb3BzIiwiaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyIsImluaXRNZXJnZVByb3BzIiwib3B0aW9ucyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9leGNsdWRlZCIsImJpbmRBY3Rpb25DcmVhdG9ycyIsImFjdGlvbkNyZWF0b3JzIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsIl9sb29wIiwiYWN0aW9uQ3JlYXRvciIsImtleSIsImFwcGx5IiwiaXNQbGFpbk9iamVjdCIsIm9iaiIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJiYXNlUHJvdG8iLCJ2ZXJpZnlQbGFpbk9iamVjdCIsInZhbHVlIiwid3JhcE1hcFRvUHJvcHNDb25zdGFudCIsImdldENvbnN0YW50IiwiaW5pdENvbnN0YW50U2VsZWN0b3IiLCJjb25zdGFudCIsImNvbnN0YW50U2VsZWN0b3IiLCJnZXREZXBlbmRzT25Pd25Qcm9wcyIsIm1hcFRvUHJvcHMiLCJCb29sZWFuIiwid3JhcE1hcFRvUHJvcHNGdW5jIiwiaW5pdFByb3h5U2VsZWN0b3IiLCJfcmVmNCIsInByb3h5IiwibWFwVG9Qcm9wc1Byb3h5Iiwic3RhdGVPckRpc3BhdGNoIiwiZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSIsInByb3BzIiwiY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkiLCJhcmciLCJ3cmFwcGVkQ29tcG9uZW50TmFtZSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE1lcmdlUHJvcHMiLCJ3cmFwTWVyZ2VQcm9wc0Z1bmMiLCJpbml0TWVyZ2VQcm9wc1Byb3h5IiwiX3JlZjUiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiaGFzUnVuT25jZSIsIm1lcmdlUHJvcHNQcm94eSIsIm5leHRNZXJnZWRQcm9wcyIsIm1lcmdlUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE5vb3BCYXRjaCIsImNhbGxiYWNrIiwiY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uIiwiZmlyc3QiLCJsYXN0IiwiY2xlYXIiLCJub3RpZnkiLCJsaXN0ZW5lciIsIm5leHQiLCJsaXN0ZW5lcnMiLCJwdXNoIiwic3Vic2NyaWJlIiwiaXNTdWJzY3JpYmVkIiwicHJldiIsInVuc3Vic2NyaWJlIiwibnVsbExpc3RlbmVycyIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInBhcmVudFN1YiIsInN1YnNjcmlwdGlvbnNBbW91bnQiLCJzZWxmU3Vic2NyaWJlZCIsInRyeVN1YnNjcmliZSIsImNsZWFudXBMaXN0ZW5lciIsInJlbW92ZWQiLCJ0cnlVbnN1YnNjcmliZSIsIm5vdGlmeU5lc3RlZFN1YnMiLCJoYW5kbGVDaGFuZ2VXcmFwcGVyIiwib25TdGF0ZUNoYW5nZSIsInRyeVN1YnNjcmliZVNlbGYiLCJ0cnlVbnN1YnNjcmliZVNlbGYiLCJnZXRMaXN0ZW5lcnMiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJpcyIsIngiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXMiLCJrZXlzQiIsImkiLCJSRUFDVF9TVEFUSUNTIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb250ZXh0VHlwZSIsImNvbnRleHRUeXBlcyIsImRlZmF1bHRQcm9wcyIsImdldERlZmF1bHRQcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm1peGlucyIsInByb3BUeXBlcyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcml0eSIsIkZPUldBUkRfUkVGX1NUQVRJQ1MiLCJyZW5kZXIiLCJNRU1PX1NUQVRJQ1MiLCJjb21wYXJlIiwiVFlQRV9TVEFUSUNTIiwiZ2V0U3RhdGljcyIsImNvbXBvbmVudCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwidGFyZ2V0U3RhdGljcyIsInNvdXJjZVN0YXRpY3MiLCJkZXNjcmlwdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJpbml0aWFsaXplQ29ubmVjdCIsIk5PX1NVQlNDUklQVElPTl9BUlJBWSIsInN0cmluZ2lmeUNvbXBvbmVudCIsIkNvbXAiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyIiwiU3RyaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzIiwiZWZmZWN0RnVuYyIsImVmZmVjdEFyZ3MiLCJkZXBlbmRlbmNpZXMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJjYXB0dXJlV3JhcHBlclByb3BzIiwibGFzdFdyYXBwZXJQcm9wcyIsImxhc3RDaGlsZFByb3BzIiwicmVuZGVySXNTY2hlZHVsZWQiLCJ3cmFwcGVyUHJvcHMiLCJjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlIiwic3Vic2NyaWJlVXBkYXRlcyIsInNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyIsImNoaWxkUHJvcHNTZWxlY3RvciIsImlzTW91bnRlZCIsImFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lciIsImRpZFVuc3Vic2NyaWJlIiwibGFzdFRocm93bkVycm9yIiwiY2hlY2tGb3JVcGRhdGVzIiwibGF0ZXN0U3RvcmVTdGF0ZSIsIm5ld0NoaWxkUHJvcHMiLCJ1bnN1YnNjcmliZVdyYXBwZXIiLCJzdHJpY3RFcXVhbCIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24iLCJjb25uZWN0IiwiX3JlZjYiLCJwdXJlIiwiX3JlZjYkYXJlU3RhdGVzRXF1YWwiLCJfcmVmNiRhcmVPd25Qcm9wc0VxdWEiLCJfcmVmNiRhcmVTdGF0ZVByb3BzRXEiLCJfcmVmNiRhcmVNZXJnZWRQcm9wc0UiLCJfcmVmNiRmb3J3YXJkUmVmIiwiZm9yd2FyZFJlZiIsIl9yZWY2JGNvbnRleHQiLCJDb250ZXh0Iiwid3JhcFdpdGhDb25uZWN0IiwiV3JhcHBlZENvbXBvbmVudCIsImlzVmFsaWQiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdEZ1bmN0aW9uIiwiX1JlYWN0JHVzZU1lbW8iLCJ1c2VNZW1vIiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZjIiLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmIiwid3JhcHBlclByb3BzMiIsIl9leGNsdWRlZDIiLCJfUmVhY3QkdXNlTWVtbzIiLCJfc2xpY2VkVG9BcnJheSIsInByb3BzQ29udGV4dCIsIkNvbnRleHRUb1VzZSIsIlJlc3VsdENvbnRleHQiLCJDb25zdW1lciIsImRpZFN0b3JlQ29tZUZyb21Qcm9wcyIsImRpZFN0b3JlQ29tZUZyb21Db250ZXh0IiwiX1JlYWN0JHVzZU1lbW8zIiwic3Vic2NyaXB0aW9uMiIsIm5vdGlmeU5lc3RlZFN1YnMyIiwiYmluZCIsIl9SZWFjdCR1c2VNZW1vNCIsIm92ZXJyaWRkZW5Db250ZXh0VmFsdWUiLCJsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yIiwiYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yIiwic3Vic2NyaWJlRm9yUmVhY3QiLCJyZWFjdExpc3RlbmVyIiwiYWN0dWFsQ2hpbGRQcm9wcyIsInJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCIsInJlZiIsInJlbmRlcmVkQ2hpbGQiLCJQcm92aWRlciIsIl9Db25uZWN0IiwibWVtbyIsIkNvbm5lY3QiLCJfZm9yd2FyZGVkIiwiZm9yd2FyZENvbm5lY3RSZWYiLCJmb3J3YXJkZWQiLCJjb25uZWN0X2RlZmF1bHQiLCJfcmVmNyIsImNoaWxkcmVuIiwic2VydmVyU3RhdGUiLCJfcmVmNyRzdGFiaWxpdHlDaGVjayIsIl9yZWY3JGlkZW50aXR5RnVuY3RpbyIsInByZXZpb3VzU3RhdGUiLCJQcm92aWRlcl9kZWZhdWx0IiwiY3JlYXRlU3RvcmVIb29rIiwidXNlU3RvcmUyIiwiX3VzZVJlZHV4Q29udGV4dDIiLCJ1c2VTdG9yZSIsImNyZWF0ZURpc3BhdGNoSG9vayIsInVzZURpc3BhdGNoMiIsInVzZURpc3BhdGNoIiwiYmF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/react-redux.mjs\n");

/***/ })

};
;